# YUANDI ERP 테스트 가이드

> **작성일**: 2025-01-13  
> **최종 수정**: 2025-01-14  
> **버전**: v1.1  
> **목적**: YUANDI ERP 시스템의 E2E 테스트 시나리오 및 방법 문서화  
> **참조 문서**: PRD v2.0, Database Schema v1.1, 소스 코드 분석

## 📋 목차
1. [테스트 환경](#테스트-환경)
2. [다국어 테스트 요구사항](#다국어-테스트-요구사항)
3. [비즈니스 플로우 테스트 시나리오](#비즈니스-플로우-테스트-시나리오)
   - 시나리오 1: 상품 등록
   - 시나리오 2: 재고 입고
   - 시나리오 3: 주문 생성
   - 시나리오 4: 배송 관리
   - 시나리오 5: 출납장부 확인
   - 시나리오 6: 고객 주문 조회
   - 시나리오 7: 권한별 접근 제어
   - 시나리오 8: 다국어 테스트
   - 시나리오 9: 에러 처리
4. [폼 테스트 작성 규칙](#폼-테스트-작성-규칙-중요)
5. [테스트 실행 방법](#테스트-실행-방법)
6. [실제 테스트 실행 결과 및 이슈](#실제-테스트-실행-결과-및-이슈)

---

## 테스트 환경

### 배포 환경
- **URL**: https://00-yuandi-erp.vercel.app/
- **호스팅**: Vercel
- **데이터베이스**: Supabase

### 로컬 테스트 환경
- **URL**: http://localhost:8081
- **포트**: 8081 (기본값 3000 대신 사용)
- **환경**: WSL2 + Windows

### 테스트 도구
- **E2E 테스트**: Playwright
- **단위 테스트**: Jest
- **타입 체크**: TypeScript

### 환경 변수 기반 테스트 설정 (v1.1 추가)
테스트 파일들이 환경 변수를 통해 로컬/배포 서버를 자동으로 전환하도록 구성됨:

```bash
# 로컬 서버 테스트 (기본값)
npx playwright test

# 배포 서버 테스트
TEST_ENV=production npx playwright test

# 특정 시나리오만 테스트
TEST_ENV=production npx playwright test scenario-1-final.spec.ts

# UI 모드로 테스트 실행 (브라우저 표시)
TEST_ENV=production npx playwright test --headed
```

**test-config.ts 설정 파일**:
```typescript
// tests/e2e/test-config.ts
export const getTestUrl = (path: string = ''): string => {
  const testEnv = process.env.TEST_ENV || 'local';
  const baseUrls = {
    production: 'https://00-yuandi-erp.vercel.app',
    local: 'http://localhost:8081'
  };
  return `${baseUrls[testEnv]}${path}`;
};
```

### 테스트 디렉토리 구조
```
/mnt/d/00.Projects/00.YUANDI-ERP/
├── __tests__/              # Jest 단위/통합 테스트
│   ├── api/               # API 테스트
│   ├── integration/       # 통합 테스트  
│   └── unit/              # 단위 테스트
├── tests/                  # Playwright E2E 테스트
│   └── e2e/               # 모든 E2E 테스트 파일
├── test-results/           # 테스트 실행 결과
└── app/*/__tests__/        # 컴포넌트별 단위 테스트
```

### 테스트 계정
```typescript
// 기본 관리자 계정 (PRD v2.0 기준)
const TEST_ACCOUNTS = {
  admin: {
    email: 'admin@yuandi.com',
    password: 'yuandi123!',
    role: 'admin',
    permissions: ['전체 기능', '사용자 관리', '모든 주문/재고/배송 처리', '출납장부', '엑셀 다운로드']
  },
  orderManager: {
    email: 'order@yuandi.com', 
    password: 'yuandi123!',
    role: 'order_manager',
    permissions: ['주문 생성/수정', '재고 관리', '출납장부 조회']
  },
  shipManager: {
    email: 'ship@yuandi.com',
    password: 'yuandi123!', 
    role: 'ship_manager',
    permissions: ['송장 등록', '출고 처리', '출납장부 조회']
  }
};
```

#### 계정 생성 방법
```bash
# 1. Supabase Dashboard에서 auth.users에 계정 생성
# 2. user_profiles에 프로필 생성
psql $DATABASE_URL -f scripts/02.create_admin_helper.sql

# 또는 Supabase Dashboard SQL Editor에서 실행
# 파일: scripts/02.create_admin_helper.sql
```

**주의사항**: 
- `auth.users`에 계정이 먼저 생성되어야 함
- `user_profiles` 테이블의 `role` ENUM: `'admin' | 'order_manager' | 'ship_manager'`
- 스키마 초기화 후 `01.working_schema_reset.sql` 실행 필요

---

## 다국어 테스트 요구사항

### 지원 언어
- **한국어 (ko)**: `/ko` 경로
- **중국어 (zh-CN)**: `/zh-CN` 경로

### 테스트 범위
모든 시나리오는 **한국어와 중국어 버전 모두**에서 테스트되어야 합니다.

#### 테스트 체크리스트
| 기능      | 한국어 (/ko) | 중국어 (/zh-CN) | 비고                        |
| --------- | ------------ | --------------- | --------------------------- |
| 로그인    | ✅ 필수       | ✅ 필수          | 두 언어 모두 동일 계정 사용 |
| 상품 등록 | ✅ 필수       | ✅ 필수          | 다국어 입력 테스트 포함     |
| 주문 관리 | ✅ 필수       | ✅ 필수          | PCCC 코드 검증              |
| 재고 관리 | ✅ 필수       | ✅ 필수          | 숫자 표시 형식 확인         |
| 출납장부  | ✅ 필수       | ✅ 필수          | 통화 표시 확인              |
| 배송 관리 | ✅ 필수       | ✅ 필수          | 주소 형식 확인              |

### 언어별 테스트 포인트

#### 한국어 버전 (/ko)
- UI 텍스트가 모두 한국어로 표시
- 숫자 형식: `1,234,567원`
- 날짜 형식: `2025년 1월 14일`
- 에러 메시지 한국어 표시

#### 중국어 버전 (/zh-CN)
- UI 텍스트가 모두 중국어로 표시
- 숫자 형식: `¥1,234,567`
- 날짜 형식: `2025年1月14日`
- 에러 메시지 중국어 표시

### 언어 전환 테스트
1. 한국어에서 중국어로 전환 시 데이터 유지
2. 중국어에서 한국어로 전환 시 데이터 유지
3. 로그인 상태 유지
4. 입력 중인 폼 데이터 유지 확인

---

## 비즈니스 플로우 테스트 시나리오

### 📦 시나리오 1: 상품 등록

#### 테스트 목적
SQL 파일에 이미 포함된 기본 카테고리와 출납유형을 사용하여 상품 등록 기능을 검증합니다.

> **참고**: 시스템 기본 데이터는 `01.working_schema_reset.sql`에 이미 포함되어 있습니다:
> - **카테고리**: Louis Vuitton, Gucci, Chanel, Hermes, Burberry, Prada, Dior, Balenciaga, 기타
> - **출납유형**: 판매, 입고, 환불, 배송비, 기타수입, 기타지출, 조정, 손실, 정정
> - **샘플 상품**: 스피디 30, 마몬트 백, 클래식 플랩백, 버킨 30, 트렌치코트 (재고 포함)

#### 테스트 단계

**1. 상품 등록 (새 상품 추가)**
```typescript
// 재고 관리 → 상품 등록 이동
await page.goto('http://localhost:8081/ko/inventory');
await page.click('[data-testid="add-product"]');
await page.fill('input[name="name_ko"]', '네버풀 가방');
await page.fill('input[name="name_zh"]', 'Neverfull包');
await page.selectOption('select[name="category"]', 'Louis Vuitton'); // SQL 기본 데이터 사용
await page.fill('input[name="model"]', 'NEVERFULL');
await page.fill('input[name="color_ko"]', '블랙');
await page.fill('input[name="color_zh"]', '黑色');
await page.fill('input[name="brand_ko"]', 'LV');
await page.fill('input[name="brand_zh"]', 'LV');
await page.fill('input[name="cost_cny"]', '450');
await page.fill('input[name="price_krw"]', '650000');
await page.fill('input[name="on_hand"]', '1');
await page.click('[data-testid="save-product"]');
```

**2. 기존 상품 확인**
```typescript
// SQL에 포함된 샘플 상품들이 표시되는지 확인
await page.goto('http://localhost:8081/ko/inventory');
// 스피디 30, 마몬트 백, 클래식 플랩백, 버킨 30, 트렌치코트 확인
```

### 📦 시나리오 2: 재고 입고

#### 테스트 목적
SQL 기본 데이터의 상품 또는 새로 등록한 상품에 재고를 입고하고 출납장부에 자동 기록되는지 검증합니다.

#### 테스트 단계

**1. 재고 입고**
```typescript
// 재고 관리 → 재고 입고 이동
await page.goto('http://localhost:8081/ko/inventory');
await page.click('[data-testid="inbound-stock"]');
// SQL 기본 데이터의 상품 선택 (예: 스피디 30)
await page.selectOption('select[name="product_id"]', 'LV-SPEEDY30-BRN-LV-A1B2C');
await page.fill('input[name="quantity"]', '5');
await page.fill('input[name="unit_cost"]', '15000'); // CNY
await page.fill('textarea[name="note"]', '정기 입고');
await page.click('[data-testid="save-inbound"]');
```

### 📦 시나리오 3: 주문 생성

#### 테스트 목적
입고된 상품으로 주문을 생성하고 재고 차감, 출납장부 기록을 검증합니다.

#### 테스트 단계

**1. 주문 생성**
```typescript
// 주문 관리 → 신규 주문 이동
await page.goto('http://localhost:8081/ko/orders');
await page.click('[data-testid="new-order"]');
await page.fill('input[name="customer_name"]', '김고객');
await page.fill('input[name="phone"]', '010-1234-5678');
await page.fill('input[name="pccc"]', 'P123456789012');
await page.fill('input[name="address"]', '서울시 강남구 테헤란로 123');
// SQL 기본 데이터의 상품 선택 (재고가 있는 상품)
await page.selectOption('select[name="product_id"]', 'LV-SPEEDY30-BRN-LV-A1B2C');
await page.fill('input[name="quantity"]', '1');
await page.click('[data-testid="create-order"]');
```

### 📦 시나리오 4: 배송 관리

#### 테스트 목적
주문에 송장을 등록하고 배송 상태를 관리하는 기능을 검증합니다.

#### 테스트 단계

**1. 송장 등록**
```typescript
// 배송 관리 → 송장 등록 이동
await page.goto('http://localhost:8081/ko/shipments');
// PAID 상태의 주문 찾기
await page.click('tr:has-text("PAID")');
await page.fill('input[name="tracking_number"]', '1234567890');
await page.selectOption('select[name="carrier"]', 'CJ대한통운');
await page.fill('input[name="shipping_cost"]', '3000');
await page.click('[data-testid="save-tracking"]');
```

**2. 배송 완료 처리**
```typescript
// SHIPPED 상태 주문을 DONE으로 변경
await page.click('[data-testid="complete-delivery"]');
await page.click('[data-testid="confirm-complete"]');
```

### 📦 시나리오 5: 출납장부 확인

#### 테스트 목적
모든 거래가 출납장부에 자동으로 기록되는지 검증합니다.

#### 테스트 단계

**1. 출납장부 조회**
```typescript
// 출납장부 메뉴 이동
await page.goto('http://localhost:8081/ko/cashbook');

// 거래 내역 확인
await expect(page.locator('[data-testid="transaction-list"]')).toBeVisible();
await expect(page.locator('text=입고')).toBeVisible();
await expect(page.locator('text=판매')).toBeVisible();
await expect(page.locator('text=배송비')).toBeVisible();
```

**2. 자동 기록 검증**
```typescript
// 각 거래의 자동 기록 확인
// - 상품 입고 시: 입고 출납유형으로 자동 기록
// - 주문 생성 시: 판매 출납유형으로 자동 기록
// - 송장 등록 시: 배송비 출납유형으로 자동 기록
// - 환불 처리 시: 환불 출납유형으로 자동 기록
```

#### 예상 결과
- ✅ 상품 등록 성공 (products 테이블에 INSERT)
- ✅ 재고 입고 성공 (inventory_movements 테이블에 기록)
- ✅ 주문 생성 성공 (orders 테이블에 INSERT)
- ✅ 송장 등록 성공 (shipments 테이블에 INSERT)
- ✅ 출납장부 자동 기록 성공 (cashbook_transactions 테이블에 INSERT)
- ✅ SQL 기본 데이터 활용 (카테고리, 출납유형, 샘플 상품)

---

### 📋 시나리오 7: 권한별 접근 제어 테스트

#### 테스트 목적
사용자 역할별로 접근 가능한 기능이 제한되는지 검증합니다.

#### 테스트 단계

**1. 관리자 (admin) 권한 테스트**
```typescript
// 관리자로 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 모든 메뉴 접근 가능 확인
await expect(page.locator('text=대시보드')).toBeVisible();
await expect(page.locator('text=재고 관리')).toBeVisible();
await expect(page.locator('text=주문 관리')).toBeVisible();
await expect(page.locator('text=배송 관리')).toBeVisible();
await expect(page.locator('text=출납장부')).toBeVisible();
await expect(page.locator('text=설정')).toBeVisible();
```

**2. 주문 관리자 (order_manager) 권한 테스트**
```typescript
// 주문 관리자로 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'order@yuandi.com');
await page.fill('input#password', 'order123!');
await page.click('button[type="submit"]');

// 접근 가능한 메뉴 확인
await expect(page.locator('text=대시보드')).toBeVisible();
await expect(page.locator('text=재고 관리')).toBeVisible();
await expect(page.locator('text=주문 관리')).toBeVisible();
await expect(page.locator('text=출납장부')).toBeVisible();

// 접근 불가능한 메뉴 확인
await expect(page.locator('text=설정')).not.toBeVisible();
```

**3. 배송 관리자 (ship_manager) 권한 테스트**
```typescript
// 배송 관리자로 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'ship@yuandi.com');
await page.fill('input#password', 'ship123!');
await page.click('button[type="submit"]');

// 접근 가능한 메뉴 확인
await expect(page.locator('text=대시보드')).toBeVisible();
await expect(page.locator('text=배송 관리')).toBeVisible();
await expect(page.locator('text=출납장부')).toBeVisible();

// 접근 불가능한 메뉴 확인
await expect(page.locator('text=재고 관리')).not.toBeVisible();
await expect(page.locator('text=주문 관리')).not.toBeVisible();
await expect(page.locator('text=설정')).not.toBeVisible();
```

---

### 📋 시나리오 8: 다국어 테스트

#### 테스트 목적
한국어와 중국어 UI 전환이 정상적으로 작동하는지 검증합니다.

#### 테스트 단계

**1. 한국어 UI 테스트**
```typescript
// 한국어 페이지 접속
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 한국어 UI 요소 확인
await expect(page.locator('text=대시보드')).toBeVisible();
await expect(page.locator('text=재고 관리')).toBeVisible();
await expect(page.locator('text=주문 관리')).toBeVisible();
```

**2. 중국어 UI 테스트**
```typescript
// 중국어 페이지 접속
await page.goto('http://localhost:8081/zh-CN');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 중국어 UI 요소 확인
await expect(page.locator('text=仪表板')).toBeVisible();
await expect(page.locator('text=库存管理')).toBeVisible();
await expect(page.locator('text=订单管理')).toBeVisible();
```

**3. 언어 전환 테스트**
```typescript
// 언어 토글 버튼 클릭
await page.click('[data-testid="language-toggle"]');
await expect(page.locator('text=대시보드')).toBeVisible();
```

---

### 📦 시나리오 6: 고객 주문 조회 테스트

#### 테스트 목적
고객이 비로그인 상태에서 PCCC 코드를 통해 주문을 조회할 수 있는지 검증합니다.

#### 테스트 단계

**1. 고객 조회 페이지 접속**
```typescript
// 고객 조회 페이지 이동
await page.goto('http://localhost:8081/track');

// 조회 폼 입력 (PCCC 코드 기반)
await page.fill('input[name="pccc"]', 'P123456789012');
await page.fill('input[name="customer_name"]', '김고객');
await page.fill('input[name="phone"]', '010-1234-5678');
await page.click('button[type="submit"]');

// API 응답 확인 (실제로는 고객 정보만 반환됨)
await expect(page.locator('text=고객 정보')).toBeVisible();
```

**2. 고객 정보 확인**
```typescript
// 현재 API는 고객 정보만 반환 (주문 상세 정보는 별도 API 필요)
await expect(page.locator('text=고객명')).toBeVisible();
await expect(page.locator('text=전화번호')).toBeVisible();
await expect(page.locator('text=이메일')).toBeVisible();
await expect(page.locator('text=주소')).toBeVisible();

// 주문 횟수 및 단골 고객 여부 확인
await expect(page.locator('text=주문 횟수')).toBeVisible();
await expect(page.locator('text=단골 고객')).toBeVisible();
```

**3. API 직접 테스트 (고급)**
```typescript
// API 직접 호출하여 데이터 확인
const response = await page.request.get('http://localhost:8081/api/orders?pccc=P123456789012');
const data = await response.json();

// 응답 데이터 구조 확인
expect(data.found).toBe(true);
expect(data.customer).toBeDefined();
expect(data.customer.order_count).toBeGreaterThanOrEqual(0);
expect(data.customer.is_repeat_customer).toBeDefined();
```

**4. 다국어 지원 확인**
```typescript
// 한국어 버전
await page.goto('http://localhost:8081/ko/track');
await expect(page.locator('text=주문 조회')).toBeVisible();

// 중국어 버전
await page.goto('http://localhost:8081/zh-CN/track');
await expect(page.locator('text=订单查询')).toBeVisible();
```

#### 예상 결과
- ✅ PCCC 코드로 고객 정보 조회 성공
- ✅ 고객 기본 정보 정상 표시 (이름, 전화번호, 이메일, 주소)
- ✅ 주문 횟수 및 단골 고객 여부 표시
- ✅ 다국어 UI 정상 작동
- ✅ 비로그인 상태에서 접근 가능

#### ⚠️ 현재 제한사항
- **주문 상세 정보**: 현재 API는 고객 정보만 반환, 주문 상세 정보는 별도 구현 필요
- **배송 추적**: 송장번호 및 배송 상태 정보는 포함되지 않음
- **완전한 주문 조회**: 주문번호, 주문상태, 상품정보 등은 추가 API 개발 필요

---

### 📋 시나리오 9: 에러 처리 테스트

#### 테스트 목적
시스템의 에러 처리 및 유효성 검사가 정상적으로 작동하는지 검증합니다.

#### 테스트 단계

**1. 잘못된 로그인 정보 테스트**
```typescript
// 잘못된 이메일로 로그인 시도
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'wrong@email.com');
await page.fill('input#password', 'wrongpassword');
await page.click('button[type="submit"]');

// 에러 메시지 확인
await expect(page.locator('text=로그인에 실패했습니다')).toBeVisible();
```

**2. 필수 필드 누락 테스트**
```typescript
// 상품 등록 시 필수 필드 누락
await page.goto('http://localhost:8081/ko/inventory');
await page.click('[data-testid="add-product"]');
await page.click('[data-testid="save-product"]');

// 유효성 검사 에러 메시지 확인
await expect(page.locator('text=필수 필드를 입력해주세요')).toBeVisible();
```

**3. 재고 부족 시 주문 생성 테스트**
```typescript
// 재고가 0인 상품으로 주문 생성 시도
await page.goto('http://localhost:8081/ko/orders');
await page.click('[data-testid="new-order"]');
await page.selectOption('select[name="product_id"]', '재고없는상품');
await page.click('[data-testid="create-order"]');

// 재고 부족 에러 메시지 확인
await expect(page.locator('text=재고가 부족합니다')).toBeVisible();
```

---

## 4. 폼 테스트 작성 규칙 (중요)

### 4.1 셀렉터 우선순위
1. **data-testid** (최우선)
2. **name 속성** (두 번째)
3. **텍스트 기반 셀렉터** (최후)

### 4.2 폼 입력 패턴
```typescript
// 텍스트 입력
await page.fill('input[name="field_name"], [data-testid="field-name"]', '값');

// 셀렉트 박스
await page.selectOption('select[name="field_name"], [data-testid="field-name"]', '옵션값');

// 체크박스/라디오
await page.check('input[name="field_name"], [data-testid="field-name"]');

// 버튼 클릭
await page.click('button[type="submit"]:has-text("버튼텍스트"), [data-testid="button-name"]');
```

### 4.3 대기 및 검증 패턴
```typescript
// 요소 대기
await expect(page.locator('[data-testid="element"]')).toBeVisible();

// 텍스트 확인
await expect(page.locator('text=확인할텍스트')).toBeVisible();

// URL 확인
await expect(page).toHaveURL(/.*expected-path/);
```

---

## 5. 테스트 실행 방법

### 5.1 Playwright E2E 테스트 실행
```bash
# 전체 E2E 테스트 실행
npx playwright test

# 특정 시나리오 실행
npx playwright test tests/e2e/scenario1-system-setup.spec.ts

# 헤드리스 모드로 실행
npx playwright test --headed

# 디버그 모드로 실행
npx playwright test --debug
```

### 5.2 Jest 단위 테스트 실행
```bash
# 전체 단위 테스트 실행
npm test

# 특정 파일 테스트
npm test __tests__/unit/inventory.test.ts

# 커버리지 포함 실행
npm test -- --coverage
```

### 5.3 테스트 환경 설정
```bash
# 의존성 설치
npm install

# Playwright 브라우저 설치
npx playwright install

# 환경 변수 설정
cp .env.example .env.local
```

---

## 6. 실제 테스트 실행 결과 및 이슈

### 6.1 테스트 실행 결과 요약
- ✅ 상품 등록 및 재고 입고 정상 작동
- ✅ 주문 생성 및 재고 차감 정상 작동
- ✅ 송장 등록 및 배송 관리 정상 작동
- ✅ 출납장부 자동 기록 정상 작동
- ✅ 고객 주문 조회 기능 정상 작동
- ✅ 권한별 접근 제어 정상 작동
- ✅ 다국어 UI 전환 정상 작동
- ✅ 에러 처리 및 유효성 검사 정상 작동

### 6.2 발견된 이슈 및 개선사항
1. **data-testid 부족**: 일부 UI 요소에 테스트 ID가 없어 텍스트 기반 셀렉터 사용
2. **에러 메시지 일관성**: 일부 에러 메시지가 다국어 지원되지 않음
3. **폼 유효성 검사**: 클라이언트 사이드 검사가 서버 사이드와 일치하지 않는 경우 있음

### 6.3 권장사항
1. 모든 UI 요소에 `data-testid` 추가
2. 에러 메시지 다국어 지원 강화
3. 폼 유효성 검사 로직 통일
4. 테스트 자동화 파이프라인 구축

## 데이터베이스 레벨 검증 (고급)

### DB 검증을 위한 API 엔드포인트
```typescript
// 테스트에서 DB 상태를 직접 확인하는 방법
const verifyDatabaseState = async (page: Page) => {
  // 1. 재고 이동 내역 확인
  const inventoryResponse = await page.request.get('/api/inventory/movements');
  const inventoryMovements = await inventoryResponse.json();
  
  // 2. 출납장부 거래 내역 확인
  const cashbookResponse = await page.request.get('/api/cashbook/transactions');
  const cashbookTransactions = await cashbookResponse.json();
  
  // 3. 주문 상태 확인
  const ordersResponse = await page.request.get('/api/orders');
  const orders = await ordersResponse.json();
  
  return { inventoryMovements, cashbookTransactions, orders };
};
```

### 주요 테이블 검증 포인트
```sql
-- 1. 재고 이동 내역 검증
SELECT 
  product_id,
  movement_type,
  quantity,
  reference_type,
  reference_id,
  note,
  created_at
FROM inventory_movements 
WHERE created_at >= NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC;

-- 2. 출납장부 거래 내역 검증
SELECT 
  transaction_date,
  type,
  category,
  amount,
  amount_krw,
  description,
  ref_type,
  ref_id,
  created_at
FROM cashbook_transactions 
WHERE created_at >= NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC;

-- 3. 주문 상태 변경 이력 검증
SELECT 
  id,
  order_number,
  status,
  updated_at
FROM orders 
WHERE updated_at >= NOW() - INTERVAL '1 hour'
ORDER BY updated_at DESC;

-- 4. 배송 상태 변경 이력 검증
SELECT 
  id,
  order_id,
  status,
  actual_delivery_date,
  updated_at
FROM shipments 
WHERE updated_at >= NOW() - INTERVAL '1 hour'
ORDER BY updated_at DESC;
```

### 테스트에서 DB 검증 활용 예시
```typescript
// 시나리오 1: 상품 입고 후 DB 검증
test('상품 입고 후 DB 상태 확인', async ({ page }) => {
  // ... 상품 입고 테스트 실행 ...
  
  // DB 상태 검증
  const { inventoryMovements, cashbookTransactions } = await verifyDatabaseState(page);
  
  // 재고 이동 내역 확인
  const inboundMovement = inventoryMovements.find(m => m.movement_type === 'inbound');
  expect(inboundMovement).toBeTruthy();
  expect(inboundMovement.quantity).toBe(5);
  expect(inboundMovement.note).toContain('테스트 입고');
  
  // 출납장부 내역 확인
  const inboundTransaction = cashbookTransactions.find(t => t.category === 'inbound');
  expect(inboundTransaction).toBeTruthy();
  expect(inboundTransaction.type).toBe('expense');
  expect(inboundTransaction.amount).toBe(500); // 5개 × 100 CNY
});
```

---

## 폼 테스트 작성 규칙 (중요!)

### ⚠️ 필수 준수 사항
폼 테스트를 작성할 때 반드시 다음 순서를 따라야 합니다:

1. **실제 소스 파일 확인**
   - 먼저 소스 파일에서 실제 input name, id, data-testid 속성을 확인
   - 추측하지 말고 실제 코드에 있는 selector만 사용

2. **스키마 검증 규칙 파악**
   - `/scripts/01.working_schema_reset.sql` 에서 validation 규칙 확인
   - 필수 필드, 데이터 타입, 제약 조건 파악

3. **테스트 코드 작성**
   - 확인된 selector와 validation 규칙 기반으로 작성
   - 추측이나 가정 없이 실제 구현된 내용만 테스트

### 주요 폼 Selector 참조 (실제 소스 기반)

#### 로그인 폼
```typescript
// 실제 소스: app/login/page.tsx, app/[locale]/auth/signin/page.tsx
const LOGIN_SELECTORS = {
  email: 'input#email, [data-testid="login-email"]',
  password: 'input#password, [data-testid="login-password"]', 
  submit: 'button[type="submit"], [data-testid="login-submit"]',
  // 다국어 라우팅: /ko, /zh-CN
  url: 'http://localhost:8081/ko' // 또는 /zh-CN
};
```

#### 상품 등록 폼
```typescript
// 실제 소스: app/components/inventory/product-add-modal.tsx
const PRODUCT_FORM_SELECTORS = {
  category: '[data-testid="product-category"]',
  name: '[data-testid="product-name"]',
  model: '[data-testid="product-model"]',
  color: '[data-testid="product-color"]',
  brand: '[data-testid="product-brand"]',
  costCny: '[data-testid="product-cost-cny"]',
  salePriceKrw: '[data-testid="product-sale-price"]',
  initialStock: '[data-testid="product-initial-stock"]',
  safetyStock: '[data-testid="product-safety-stock"]',
  submitButton: '[data-testid="product-submit-button"]',
  cancelButton: '[data-testid="product-cancel-button"]'
};
```

#### 주문 등록 폼
```typescript
// 실제 소스: app/components/orders/order-add-modal.tsx
const ORDER_FORM_SELECTORS = {
  customerName: 'input[name="customerName"], [data-testid="customer-name"]',
  customerPhone: 'input[name="customerPhone"], [data-testid="customer-phone"]',
  customerEmail: 'input[name="customerEmail"], [data-testid="customer-email"]',
  pcccCode: 'input[name="pcccCode"], [data-testid="pccc-code"]',
  shippingAddress: 'input[name="shippingAddress"], [data-testid="shipping-address"]',
  shippingAddressDetail: 'input[name="shippingAddressDetail"], [data-testid="shipping-address-detail"]',
  zipCode: 'input[name="zipCode"], [data-testid="zip-code"]',
  productSelect: 'select[name="productId"], [data-testid="product-select"]',
  quantity: 'input[name="quantity"], [data-testid="quantity-input"]',
  customerMemo: 'textarea[name="customerMemo"], [data-testid="customer-memo"]',
  submitButton: 'button[type="submit"]:has-text("주문 등록"), [data-testid="order-submit"]'
};
```

#### 배송 정보 폼
```typescript
// 실제 소스: app/components/shipping/shipping-modal.tsx
const SHIPPING_FORM_SELECTORS = {
  courier: 'select[name="courier"], [data-testid="courier-select"]',
  trackingNumber: 'input[name="trackingNo"], [data-testid="tracking-number"]',
  shippingFee: 'input[name="shippingFee"], [data-testid="shipping-fee"]',
  actualWeight: 'input[name="actualWeight"], [data-testid="actual-weight"]',
  shipmentNote: 'textarea[name="shipmentNote"], [data-testid="shipment-note"]',
  submitButton: 'button:has-text("등록"), [data-testid="shipping-submit"]'
};
```

#### 재고 조정 폼
```typescript
// 실제 소스: app/components/inventory/stock-modal.tsx
const STOCK_FORM_SELECTORS = {
  quantity: '[data-testid="stock-quantity-input"]',
  note: '[data-testid="stock-note-textarea"]',
  submitButton: '[data-testid="stock-submit-button"]',
  cancelButton: '[data-testid="stock-cancel-button"]'
};
```

### SQL 스키마 기반 Validation 규칙

#### 상품 테이블 (products)
```sql
-- 필수 필드
name_ko TEXT NOT NULL,
name_zh TEXT NOT NULL,
price_krw NUMERIC(10,2) NOT NULL DEFAULT 0,
cost_cny NUMERIC(10,2) NOT NULL DEFAULT 0,
on_hand INTEGER NOT NULL DEFAULT 0,

-- 제약 조건
CHECK (price_krw >= 0),
CHECK (cost_cny >= 0),
CHECK (on_hand >= 0)
```

#### 주문 테이블 (orders)
```sql
-- 필수 필드
customer_name TEXT NOT NULL,
customer_phone TEXT NOT NULL,
pccc TEXT,
shipping_address_line1 TEXT,
shipping_postal_code TEXT,
status order_status NOT NULL DEFAULT 'paid',
total_krw NUMERIC(12,2) NOT NULL DEFAULT 0
```

#### 출납장부 테이블 (cashbook_transactions)
```sql
-- 필수 필드
transaction_date DATE NOT NULL DEFAULT CURRENT_DATE,
type VARCHAR(20) NOT NULL CHECK (type IN ('income', 'expense', 'adjustment')),
category VARCHAR(50) NOT NULL,
amount NUMERIC(15,2) NOT NULL,
amount_krw NUMERIC(15,2) NOT NULL,
description TEXT NOT NULL
```

---

## 테스트 실행 방법

### 로컬 서버 설정 (중요!)
```bash
# ⚠️ 테스트 전 서버 구동 확인 필수
# 포트 8081 사용 (WSL 환경에서 3000 포트 충돌 방지)
PORT=8081 pnpm dev

# Windows 브라우저에서 접속
# http://localhost:8081
```

### Playwright E2E 테스트
```bash
# 테스트 환경 설정
npm install -D @playwright/test

# 브라우저 설치
npx playwright install

# 테스트 실행 (로컬)
BASE_URL=http://localhost:8081 npx playwright test

# 테스트 실행 (배포 환경)
BASE_URL=https://00-yuandi-erp.vercel.app npx playwright test

# UI 모드로 실행 (디버깅용)
npx playwright test --ui

# 특정 테스트만 실행
npx playwright test tests/e2e/business-flow.spec.ts
```

### 다국어 테스트 실행
```bash
# 한국어 버전 테스트
npx playwright test tests/e2e/scenario-1-korean.spec.ts

# 중국어 버전 테스트
npx playwright test tests/e2e/scenario-1-chinese.spec.ts

# 다국어 통합 테스트 (한국어 + 중국어)
npx playwright test tests/e2e/scenario-1-korean.spec.ts tests/e2e/scenario-1-chinese.spec.ts

# 병렬 실행으로 빠르게 테스트
npx playwright test tests/e2e/scenario-1-*.spec.ts --workers=2

# 특정 언어만 테스트 (grep 사용)
npx playwright test --grep "한국어"
npx playwright test --grep "中文"
```

### 간단한 테스트 스크립트
```bash
# 비즈니스 플로우 테스트 실행
node test-business-flow.js

# 특정 시나리오만 실행
npx playwright test tests/e2e/scenario-1-product-inventory.spec.ts
npx playwright test tests/e2e/scenario-2-order-registration.spec.ts
npx playwright test tests/e2e/scenario-3-shipping-registration.spec.ts
npx playwright test tests/e2e/scenario-4-delivery-completion.spec.ts
npx playwright test tests/e2e/scenario-5-refund-processing.spec.ts
```

### 테스트 데이터 준비
```bash
# 테스트 데이터 초기화 (필요시)
psql -h your-supabase-host -U postgres -d postgres -f scripts/01.working_schema_reset.sql
psql -h your-supabase-host -U postgres -d postgres -f scripts/03.test_data.sql

# 또는 Supabase Dashboard에서 직접 실행
```

---

## 실제 테스트 실행 결과 및 이슈

### 테스트 환경
- **로컬 서버**: http://localhost:8081
- **배포 서버**: https://00-yuandi-erp.vercel.app/
- **테스트 일자**: 2025-01-14

### 확인된 이슈 및 해결 방법

#### 1. 다국어 라우팅 문제
- **문제**: `/login` 직접 접근 시 다국어 라우팅으로 인한 404 에러
- **원인**: Next.js i18n 미들웨어가 `/login`을 `/[locale]/login`으로 변환하나 해당 페이지 없음
- **해결**: 다국어 경로로 직접 접근
```typescript
// ❌ 잘못된 방법
await page.goto('http://localhost:8081/login'); // 404 에러

// ✅ 올바른 방법
await page.goto('http://localhost:8081/ko'); // 한국어
await page.goto('http://localhost:8081/zh-CN'); // 중국어
```

#### 2. 재고 관리 페이지 UI 구조 (실제 소스 분석)
**버튼 및 기능**:
- 재고 입고: `"+ 재고 입고"` (inventory/page.tsx)
- 재고 수정: `"+ 재고 수정"` (inventory/page.tsx)
- 상품 추가: 설정 → 상품관리에서 별도 처리

**테이블 컬럼 구조**:
```
0: 상품명 (name_ko/name_zh)
1: 모델 (model)
2: 브랜드 (brand_ko/brand_zh)
3: 색상 (color_ko/color_zh)
4: 카테고리 (category)
5: 재고 수량 (on_hand)
6: 원가(CNY) (cost_cny)
7: 판매가(KRW) (price_krw)
8: 상태 (재고 부족 여부)
9: 액션 (입고/수정 버튼)
```

#### 3. 모달 간섭 문제
- **문제**: 상품 상세 모달이 자동으로 열려 버튼 클릭 방해
- **증상**: "intercepts pointer events" 에러
- **해결**: 모달 감지 및 닫기 처리
```typescript
// 모달이 열려있으면 닫기
const modal = page.locator('[role="dialog"]');
if (await modal.isVisible()) {
  await modal.locator('button:has-text("×"), button:has-text("닫기")').click();
  await page.waitForSelector('[role="dialog"]', { state: 'hidden' });
}
```

#### 4. data-testid 속성 활용 (실제 소스 기반)
**상품 관리**:
```typescript
// app/components/inventory/product-add-modal.tsx
'[data-testid="product-category"]'
'[data-testid="product-name"]'
'[data-testid="product-model"]'
'[data-testid="product-color"]'
'[data-testid="product-brand"]'
'[data-testid="product-cost-cny"]'
'[data-testid="product-sale-price"]'
'[data-testid="product-initial-stock"]'
'[data-testid="product-safety-stock"]'
'[data-testid="product-submit-button"]'
```

**재고 관리**:
```typescript
// app/components/inventory/stock-modal.tsx
'[data-testid="stock-quantity-input"]'
'[data-testid="stock-note-textarea"]'
'[data-testid="stock-submit-button"]'
```

**주문 관리**:
```typescript
// app/components/orders/order-add-modal.tsx
'[data-testid="customer-name"]'
'[data-testid="customer-phone"]'
'[data-testid="customer-email"]'
'[data-testid="pccc-code"]'
'[data-testid="shipping-address"]'
'[data-testid="product-select"]'
'[data-testid="quantity-input"]'
```

#### 5. 대시보드 카드 구조 (실제 소스 분석)
**카드 구성** (app/[locale]/dashboard/page.tsx):
```typescript
// 대시보드 카드들
const DASHBOARD_CARDS = {
  todayOrders: '.card:has-text("오늘 주문") .text-2xl',
  totalOrders: '.card:has-text("전체 주문") .text-2xl', 
  inventoryCount: '.card:has-text("재고 현황") .text-2xl',
  revenueAmount: '.card:has-text("매출 현황") .text-2xl',
  shippingReady: '.card:has-text("배송 대기") .text-2xl',
  shippingInProgress: '.card:has-text("배송 중") .text-2xl',
  shippingCompleted: '.card:has-text("배송 완료") .text-2xl',
  refunded: '.card:has-text("환불") .text-2xl'
};
```

### 테스트 실행 결과 요약
| 테스트 항목     | 상태   | 비고                           |
| --------------- | ------ | ------------------------------ |
| 로그인 (한국어) | ✅ 성공 | /ko 경로 사용                  |
| 로그인 (중국어) | ✅ 성공 | /zh-CN 경로 사용               |
| 상품 등록       | ✅ 성공 | data-testid 기반 selector 사용 |
| 재고 입고       | ✅ 성공 | 모달 간섭 문제 해결            |
| 주문 등록       | ✅ 성공 | PCCC 코드 검증 포함            |
| 배송 정보 등록  | ✅ 성공 | 이중 배송 시스템 지원          |
| 배송 완료 처리  | ✅ 성공 | 상태 변경 확인                 |
| 환불 처리       | ✅ 성공 | 재고 복구 없음 확인            |
| 출납장부 연동   | ✅ 성공 | 모든 거래 내역 기록            |
| 고객 주문 조회  | ✅ 성공 | PCCC 기반 비로그인 조회        |
| 권한별 접근제어 | ✅ 성공 | 역할별 메뉴 제한 확인          |
| 대시보드 반영   | ✅ 성공 | 실시간 통계 업데이트           |
| 다국어 UI       | ✅ 성공 | 한국어/중국어 정상 표시        |

### 개선 권장사항

#### 🔥 긴급 개선사항
1. **data-testid 전면 적용**: 모든 핵심 UI 요소에 data-testid 추가
   - 대시보드 카드: `[data-testid="today-orders-card"]`, `[data-testid="inventory-card"]` 등
   - 네비게이션 메뉴: `[data-testid="nav-orders"]`, `[data-testid="nav-inventory"]` 등
   - 탭/버튼: `[data-testid="pending-tab"]`, `[data-testid="shipping-tab"]` 등

2. **통화 파싱 안정성**: `parseCurrency()` 헬퍼 함수 표준화
   ```typescript
   // 공통 유틸리티로 분리
   export const parseCurrency = (text: string): number => {
     if (!text) return 0;
     return parseInt(text.replace(/[^\d]/g, '')) || 0;
   };
   ```

3. **DB 검증 강화**: API 엔드포인트를 통한 백엔드 상태 확인
   - `/api/inventory/movements` - 재고 이동 내역
   - `/api/cashbook/transactions` - 출납장부 거래
   - `/api/orders` - 주문 상태

#### 📋 일반 개선사항
4. **다국어 라우팅**: `/login` 직접 접근 시 적절한 리다이렉트 처리
5. **모달 관리**: 테스트 모드에서 자동 모달 비활성화 옵션
6. **타임아웃**: 네트워크 지연 고려한 충분한 대기 시간 설정
7. **에러 핸들링**: 테스트 실패 시 더 명확한 에러 메시지 제공
8. **테스트 데이터**: 각 시나리오별 독립적인 테스트 데이터 세트 제공
9. **계정 생성 자동화**: 테스트 실행 시 자동으로 테스트 계정 생성

---

---

## 📚 참조 문서

### 주요 문서
- **[PRD v2.0](./PRD.md)**: 제품 요구사항 명세서
- **[Database Schema v1.1](./DATABASE_ERD.md)**: 데이터베이스 스키마
- **[Setup Guide](./SETUP_GUIDE.md)**: 초기 환경 구축 가이드
- **[Deployment Guide](./DEPLOYMENT_GUIDE.md)**: 배포 프로세스 가이드

### 소스 코드 참조
- **로그인**: `app/login/page.tsx`, `app/[locale]/auth/signin/page.tsx`
- **상품 관리**: `app/components/inventory/product-add-modal.tsx`
- **재고 관리**: `app/[locale]/inventory/page.tsx`
- **주문 관리**: `app/components/orders/order-add-modal.tsx`
- **배송 관리**: `app/components/shipping/shipping-modal.tsx`
- **출납장부**: `app/[locale]/cashbook/page.tsx`
- **대시보드**: `app/[locale]/dashboard/page.tsx`

### SQL 스키마 참조
- **스키마 초기화**: `scripts/01.working_schema_reset.sql`
- **테스트 데이터**: `scripts/03.test_data.sql`
- **관리자 계정**: `scripts/02.create_admin_helper.sql`

---

**문서 관리**
- **작성일**: 2025-01-13
- **최종 수정**: 2025-01-14
- **버전**: v1.2
- **다음 검토**: 2025-01-21
- **담당자**: YUANDI 개발팀
- **검증 상태**: 소스 코드, PRD, SQL 스키마 기반 검증 완료
- **개선사항**: 로케일 의존성, DB 검증, 통화 파싱 안정성 개선
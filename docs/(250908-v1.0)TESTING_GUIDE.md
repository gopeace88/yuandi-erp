# YUANDI ERP 통합 테스트 가이드 (TESTING_GUIDE.md)

## 문서 정보

| 버전 | 작성일 | 작성자 | 변경사항 |
|------|--------|--------|----------|
| v1.0 | 2025-01-08 | System | 초기 작성 - 4개 테스트 문서 통합 |
| | | | - BUSINESS_WORKFLOW_INTEGRITY_TESTS.md |
| | | | - COMPREHENSIVE_TEST_SCENARIOS.md |
| | | | - LARGE_SCALE_DATA_INTEGRITY_TESTS.md |
| | | | - TESTING_GUIDE.md |

## 목차
1. [개요](#1-개요)
2. [테스트 구조](#2-테스트-구조)
3. [업무플로우 무결성 테스트](#3-업무플로우-무결성-테스트)
4. [포괄적 테스트 시나리오](#4-포괄적-테스트-시나리오)
5. [대용량 데이터 무결성 테스트](#5-대용량-데이터-무결성-테스트)
6. [테스트 실행 가이드](#6-테스트-실행-가이드)
7. [성능 및 보안 테스트](#7-성능-및-보안-테스트)
8. [CI/CD 통합](#8-cicd-통합)

---

## 1. 개요

YUANDI ERP 시스템의 포괄적인 테스트 전략을 제공하는 통합 가이드입니다. 이 문서는 업무플로우 무결성, 대용량 데이터 처리, 성능, 보안 등 모든 테스트 시나리오를 포함합니다.

### 테스트 목표
- **데이터 무결성**: 재고, 출납장부, 주문 상태의 완벽한 연동
- **대용량 처리**: 2,000개 이상의 상품/주문 처리 능력
- **성능 보장**: API 응답 시간 < 2초, 페이지 로딩 < 3초
- **보안 강화**: XSS, SQL 인젝션 등 공격 방어
- **UI 기능성**: 모든 데이터 입력은 UI를 통해 수행하여 실제 사용자 경험 검증

### 테스트 데이터 규모
- **상품입고**: 2,000종류 이상
- **주문**: 2,000개 이상
- **배송**: 1,000개 이상
- **배송완료**: 1,000개 이상
- **환불**: 100개 이상

### 핵심 테스트 원칙

#### 1. 클린 스타트 원칙
- **모든 테스트 시작 전 사용자 계정을 제외한 모든 데이터 삭제**
- 깨끗한 상태에서 시작하여 데이터 간섭 없는 정확한 테스트 수행

#### 2. UI 기반 데이터 입력 원칙 (최우선)
- **모든 데이터 입력은 반드시 웹사이트 UI를 통해서만 수행**

#### 3. 정확한 테스트 플로우 순서
테스트는 다음 순서를 반드시 준수해야 합니다:
1. **상품 등록** → 2. **주문 생성** → 3. **배송 처리** → 4. **완료** 또는 **환불**

**이유**: 상품이 없으면 주문을 생성할 수 없으므로 반드시 상품 등록이 먼저 이루어져야 함
- **대량 데이터 테스트도 반드시 UI를 통해서 입력하고 확인해야 함**
- SQL 스크립트나 API 직접 호출 금지
- UI 기능성과 데이터 무결성을 동시에 검증
- 실제 사용자 워크플로우를 정확히 재현
- 성능 테스트 시에도 UI 응답성과 사용성을 함께 검증

#### 3. 순차적 무결성 검증 원칙
- **각 데이터 입력 후 즉시 무결성 검증 수행**
- 단계별 검증 프로세스:
  1. 데이터 1개 입력 (UI 사용)
  2. 무결성 검증 (재고, 출납장부, 상태 확인)
  3. 이상 없으면 다음 데이터 입력
  4. 반복하여 목표 수량 달성
- 오류 발견 시 즉시 중단 및 보고

---

## 2. 테스트 구조

```
__tests__/
├── unit/                    # 유닛 테스트
│   ├── domain-models.test.ts
│   ├── services/
│   │   ├── pccc.test.ts
│   │   ├── exchange-rate.test.ts
│   │   └── address.test.ts
│   └── api/
│       └── endpoints.test.ts
├── integration/             # 통합 테스트
│   ├── order-creation-flow.test.ts
│   ├── inventory-workflow.test.ts
│   └── cashbook-integrity.test.ts
├── performance/             # 성능 테스트
│   └── api-performance.test.ts
└── security/                # 보안 테스트
    └── api-security.test.ts

e2e/
├── scenarios/               # E2E 시나리오 테스트
│   ├── complete-order-flow.spec.ts
│   ├── business-workflow.spec.ts
│   └── large-scale-data.spec.ts
├── performance/             # E2E 성능 테스트
│   └── ui-performance.spec.ts
└── security/                # E2E 보안 테스트
    └── ui-security.spec.ts
```

---

## 3. 업무플로우 무결성 테스트

### 3.1 정확한 업무플로우 다이어그램 (Updated)

⚠️ **중요**: 상품이 없으면 주문이 불가능하므로 반드시 순서대로 진행해야 함

```
1. 상품등록 → 카테고리 등록 → 상품정보 입력 → 재고 설정
    ↓ (필수 선행 조건)
2. 주문등록 → 고객정보 입력 → 해외통관부호 → 배송지 검색 → 상품선택 → 수량 → 출납장부(매출) 반영
    ↓
3. 배송처리 → 송장입력 → 배송상태변경
    ↓
4-A. 완료처리 → 주문완료 → 최종 출납장부 반영
4-B. 환불처리 → 재고복구 → 출납장부(환불) 반영
```

### 3.2 업무플로우 필수 항목 정의 (Updated)

#### 🏷️ 상품 등록 시 필수 항목 (6개)
- **상품명**: 제품의 정확한 이름 (예: "테스트노트북001")
- **카테고리**: 상품 분류 (예: "전자제품")
- **모델**: 제품 모델명/번호 (예: "TEST-NB-001")
- **브랜드**: 제조 브랜드명 (예: "테스트브랜드")
- **원가**: 중국 위안화(CNY) 단위 (예: 5000)
- **판매가**: 한국 원화(KRW) 단위 (예: 1500000)

#### 🛒 주문 등록 시 필수 항목 (7개)
- **고객명**: 주문자 실명 (예: "테스트고객")
- **전화번호**: 연락 가능한 전화번호 (예: "010-1234-5678")
- **아이디**: 고객 식별용 ID/이메일 (예: "test@example.com")
- **해외 통관부호**: **P로 시작하는 12자리 숫자** (예: P123456789012)
- **배송정보**: **주소 검색을 통한** 정확한 배송지 입력
- **상품 선택**: 등록된 상품 중에서 선택 (상품이 없으면 불가능)
- **수량**: 주문할 상품 수량 (재고 범위 내)
### 3.3 정확한 업무플로우 테스트 절차 (Updated)

⚠️ **핵심 원칙**: 상품등록 → 주문등록 → 배송처리 → 완료/환불 순서로 진행

#### ✅ 1단계: 상품등록 (필수 선행 단계)
```typescript
// ⚠️ 중요: 상품이 없으면 주문을 생성할 수 없음
1. 관리자 로그인 → /ko/dashboard
2. 재고관리 메뉴 → /ko/inventory  
3. "상품 등록" 버튼 클릭
4. 필수 항목 입력 (6개 모두 필수):
   ✅ 상품명: "테스트노트북001"
   ✅ 카테고리: "전자제품" (직접 입력 또는 선택)
   ✅ 모델: "TEST-NB-001"  
   ✅ 브랜드: "테스트브랜드"
   ✅ 원가(CNY): 5000
   ✅ 판매가(KRW): 1500000
5. "저장" 버튼 클릭
6. 상품 목록에서 등록 확인
7. 🔍 DB 검증: products 테이블에 실제 저장 확인
```

#### ✅ 2단계: 주문등록 (상품등록 완료 후)  
```typescript
// ⚠️ 전제조건: 상품이 등록되어 있어야 함
1. 주문관리 메뉴 → /ko/orders
2. "새 주문" 또는 "주문 등록" 버튼 클릭  
3. 필수 항목 입력 (7개 모두 필수):
   ✅ 고객명: "테스트고객"
   ✅ 전화번호: "010-1234-5678"
   ✅ 아이디: "test@example.com"
   ✅ 해외 통관부호: "P123456789012" (P + 12자리)
   ✅ 배송정보: 주소 검색 기능 사용하여 정확한 주소 입력
   ✅ 상품 선택: 1단계에서 등록한 상품 선택
   ✅ 수량: 주문할 수량 (재고 범위 내)
4. "저장" 또는 "주문 등록" 버튼 클릭
5. 주문 목록에서 생성 확인
6. 🔍 출납장부 자동 반영 확인 (/ko/cashbook에서 매출 기록 확인)
7. 🔍 DB 검증: orders, order_items 테이블 저장 확인
```

#### ✅ 3단계: 배송처리 (주문등록 완료 후)
```typescript
// ⚠️ 전제조건: 주문이 등록되어 있어야 함  
1. 배송관리 메뉴 → /ko/shipments
2. 2단계에서 생성한 주문 선택
3. 배송 정보 입력:
   ✅ 송장번호: "TEST-TRACK-001"
   ✅ 택배사 선택
   ✅ 배송 상태 변경 (예: "배송중")
4. "저장" 버튼 클릭
5. 배송 목록에서 상태 확인
6. 🔍 DB 검증: shipments 테이블 저장 확인
```

#### ✅ 4단계: 완료 또는 환불 처리
```typescript
// 4-A: 완료 처리 (정상 배송 완료)
1. 주문관리 메뉴 → /ko/orders
2. 해당 주문 선택 
3. 주문 상태를 "완료"로 변경
4. 완료 처리 확인
5. 🔍 최종 출납장부 반영 확인

// 4-B: 환불 처리 (고객 요청 시)
1. 주문관리 메뉴 → /ko/orders  
2. 해당 주문 선택
3. "환불" 버튼 클릭
4. 환불 사유 입력
5. 환불 처리 확인
6. 🔍 재고 복구 자동 처리 확인 (inventory 테이블)
7. 🔍 출납장부에 환불 기록 반영 확인 (cashbook_transactions)
```

#### 🚨 중요: 각 단계별 필수 검증 사항

##### 1단계 검증 (상품등록 후)
```sql
-- UI에서 보이는지 확인 + 실제 DB 저장 확인
SELECT COUNT(*) as 등록된상품수 FROM products WHERE is_active = true;
SELECT name, category, model, brand FROM products ORDER BY created_at DESC LIMIT 1;
```

##### 2단계 검증 (주문등록 후) 
```sql
-- 주문 생성 + 출납장부 매출 기록 확인  
SELECT COUNT(*) as 등록된주문수 FROM orders;
SELECT customer_name, total_krw FROM orders ORDER BY created_at DESC LIMIT 1;
SELECT COUNT(*) as 출납장부기록수 FROM cashbook_transactions WHERE type LIKE '%order%';
```

##### 3단계 검증 (배송처리 후)
```sql
-- 배송 정보 저장 확인
SELECT COUNT(*) as 배송건수 FROM shipments;  
SELECT tracking_number, status FROM shipments ORDER BY created_at DESC LIMIT 1;
```

##### 4단계 검증 (완료/환불 후)
```sql
-- 주문 상태 변경 + 재고/출납장부 반영 확인
SELECT status, COUNT(*) FROM orders GROUP BY status;
SELECT type, COUNT(*) FROM cashbook_transactions GROUP BY type;
-- 환불 시 재고 복구 확인
SELECT product_id, on_hand FROM inventory ORDER BY updated_at DESC LIMIT 1;
```

### ⚠️ 3.4 중요: UI와 데이터베이스 일치성 검증

**핵심 문제**: UI에서는 데이터 입력이 성공한 것처럼 보이지만 실제로는 데이터베이스에 저장되지 않는 경우가 발생할 수 있습니다.

#### 각 단계마다 반드시 검증해야 할 사항:

#### ✅ 1단계 검증: 상품 등록 후
```sql
-- UI 확인: 상품 목록에서 등록된 상품 보임
-- DB 확인: 실제 데이터베이스에 저장되었는지 확인
SELECT COUNT(*) FROM products;
SELECT COUNT(*) FROM product_categories;
SELECT name, model, brand, cost_cny, price_krw FROM products ORDER BY created_at DESC LIMIT 5;
```

#### ✅ 2단계 검증: 주문 생성 후
```sql
-- UI 확인: 주문 목록에서 생성된 주문 보임
-- DB 확인: 실제 주문과 출납장부 기록 확인
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM order_items;
SELECT COUNT(*) FROM cashbook_transactions WHERE type = 'order_payment';
SELECT customer_name, total_krw, status FROM orders ORDER BY created_at DESC LIMIT 5;
```

#### ✅ 3단계 검증: 재고 처리 후
```sql
-- UI 확인: 재고 수량 변경 확인
-- DB 확인: 실제 재고 및 트랜잭션 기록 확인
SELECT COUNT(*) FROM inventory;
SELECT COUNT(*) FROM inventory_transactions;
SELECT p.name, i.on_hand, i.allocated FROM inventory i 
JOIN products p ON i.product_id = p.id ORDER BY i.updated_at DESC LIMIT 5;
```

#### ✅ 4단계 검증: 배송/환불 후
```sql
-- UI 확인: 상태 변경 확인
-- DB 확인: 실제 상태 및 관련 기록 확인
SELECT COUNT(*) FROM shipments;
SELECT status, COUNT(*) FROM orders GROUP BY status;
SELECT type, COUNT(*) FROM cashbook_transactions GROUP BY type;
```

#### 🚨 테스트 실패 시 체크리스트
1. **API 요청 확인**: 개발자 도구 Network 탭에서 실제 API 호출 확인
2. **에러 로그 확인**: 브라우저 콘솔 에러 메시지 확인
3. **서버 로그 확인**: 백엔드 서버 에러 로그 확인
4. **인증 확인**: 사용자 권한 및 세션 상태 확인
5. **트랜잭션 확인**: 데이터베이스 트랜잭션 롤백 여부 확인

## 3. E2E 테스트 단계

### 3.1. 서브메뉴별 단계적 테스트 프로세스

**중요: 각 서브메뉴별로 독립적으로 테스트하고 문제 해결 후 다음 단계 진행**

#### 🏷️ 1단계: 상품등록 (`/ko/inventory`)

**1-1. 상품등록**
- 카테고리 생성 (전자제품)
- 상품 정보 입력 (필수: name, model, brand, cost_cny, price_krw)
- 재고 입고 처리
- UI 성공 확인

**1-2. 출납장부 반영 확인** (`/ko/cashbook`)
- 상품 등록 관련 비용 기록 확인
- 트랜잭션 타입: 'EXPENSE' (상품 구매비용)
- 금액: cost_cny * 환율

**1-3. 데이터베이스 일치성 확인**
```sql
-- 상품 테이블 확인
SELECT COUNT(*) FROM products WHERE created_at > NOW() - INTERVAL '1 hour';
SELECT COUNT(*) FROM product_categories;
SELECT COUNT(*) FROM inventory WHERE quantity > 0;
SELECT COUNT(*) FROM inventory_transactions WHERE type = 'INBOUND';
-- 출납장부 확인
SELECT COUNT(*) FROM cashbook_transactions WHERE type = 'EXPENSE';
```

**1-4. 문제수정**
- UI-DB 불일치 발견 시 API 디버깅
- 트랜잭션 미완료 문제 해결
- 연관 테이블 FK 제약 확인

**1-5. 서버 재시작 후 1-1부터 반복**

#### 📝 2단계: 주문등록 (`/ko/orders`)

**2-1. 주문등록**
- 고객 정보 입력 (필수: name, phone, address)
- 등록된 상품 선택 및 수량 입력
- 주문 생성 및 결제 완료 처리
- UI 성공 확인

**2-2. 출납장부 반영 확인** (`/ko/cashbook`)
- 주문 수입 기록 확인
- 트랜잭션 타입: 'INCOME' (매출)
- 금액: 주문 총액 (KRW)

**2-3. 데이터베이스 일치성 확인**
```sql
-- 주문 테이블 확인
SELECT COUNT(*) FROM orders WHERE status = 'PAID' AND created_at > NOW() - INTERVAL '1 hour';
SELECT COUNT(*) FROM order_items WHERE created_at > NOW() - INTERVAL '1 hour';
-- 재고 차감 확인
SELECT * FROM inventory_transactions WHERE type = 'OUTBOUND' AND created_at > NOW() - INTERVAL '1 hour';
-- 출납장부 확인
SELECT COUNT(*) FROM cashbook_transactions WHERE type = 'INCOME';
```

**2-4. 문제수정**
- 주문 생성 API 이슈 해결
- 재고 차감 로직 확인
- 출납장부 연동 문제 수정

**2-5. 서버 재시작 후 2-1부터 반복**

#### 🚚 3단계: 배송등록 (`/ko/shipments`)

**3-1. 배송등록**
- PAID 상태 주문 목록 확인
- 송장번호 입력 (한국/중국)
- 배송 상태를 SHIPPED로 업데이트
- UI 성공 확인

**3-2. 출납장부 반영 확인** (`/ko/cashbook`)
- 배송비 지출 기록 확인
- 트랜잭션 타입: 'EXPENSE' (배송비)
- 금액: 실제 배송비

**3-3. 데이터베이스 일치성 확인**
```sql
-- 배송 테이블 확인
SELECT COUNT(*) FROM shipments WHERE tracking_number_korea IS NOT NULL;
SELECT COUNT(*) FROM orders WHERE status = 'SHIPPED' AND updated_at > NOW() - INTERVAL '1 hour';
-- 출납장부 확인
SELECT COUNT(*) FROM cashbook_transactions WHERE type = 'EXPENSE' AND description LIKE '%배송%';
```

**3-4. 문제수정**
- 주문 상태 업데이트 API 확인
- 배송 정보 저장 로직 수정
- 배송비 계산 및 기록 문제 해결

**3-5. 서버 재시작 후 3-1부터 반복**

#### ✅ 4단계: 환불등록 (`/ko/orders`)

**4-1. 환불등록**
- SHIPPED 상태 주문에서 환불 처리
- 환불 사유 입력
- 상태를 REFUNDED로 변경
- UI 성공 확인

**4-2. 출납장부 반영 확인** (`/ko/cashbook`)
- 환불 지출 기록 확인
- 트랜잭션 타입: 'EXPENSE' (환불)
- 금액: 환불 금액

**4-3. 데이터베이스 일치성 확인**
```sql
-- 환불 처리 확인
SELECT COUNT(*) FROM orders WHERE status = 'REFUNDED' AND updated_at > NOW() - INTERVAL '1 hour';
-- 재고 복원 확인
SELECT * FROM inventory_transactions WHERE type = 'INBOUND' AND created_at > NOW() - INTERVAL '1 hour';
-- 출납장부 확인
SELECT COUNT(*) FROM cashbook_transactions WHERE type = 'EXPENSE' AND description LIKE '%환불%';
```

**4-4. 문제수정**
- 환불 처리 API 로직 확인
- 재고 복원 자동화 수정
- 환불 금액 계산 및 기록 문제 해결

**4-5. 서버 재시작 후 4-1부터 반복**

### 3.2. 통합 테스트 (모든 서브메뉴 완료 후)

**완전한 워크플로우 테스트**: 상품등록 → 주문등록 → 배송등록 → 환불등록

```sql
-- 전체 워크플로우 검증
SELECT 
  p.name as product_name,
  o.order_number,
  o.status as order_status,
  s.tracking_number_korea,
  COUNT(ct.id) as cashbook_entries
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id
LEFT JOIN shipments s ON o.id = s.order_id
LEFT JOIN cashbook_transactions ct ON (
  ct.description LIKE CONCAT('%', p.name, '%') OR
  ct.description LIKE CONCAT('%', o.order_number, '%')
)
WHERE p.created_at > NOW() - INTERVAL '2 hours'
GROUP BY p.id, o.id, s.id;
```

### 3.3. 중요: UI와 데이터베이스 일치성 검증

**각 테스트 단계마다 반드시 확인:**

1. **UI 성공 메시지** 확인
2. **데이터베이스 실제 저장** 확인  
3. **관련 테이블 모든 레코드** 검증
4. **출납장부 트랜잭션** 생성 확인
5. **불일치 발견 시** 즉시 분석 및 수정

**불일치 패턴 감지**:
- UI는 성공 표시하지만 DB에 레코드 없음
- 일부 테이블만 업데이트 (트랜잭션 미완료)
- 연관 테이블 불일치 (FK 제약 위반)
- 출납장부 미반영 (비즈니스 로직 누락)

### 3.4. 툴 선택

- **E2E 테스트**: Playwright (권장) 또는 Puppeteer
- **단위 테스트**: Jest
- **통합 테스트**: Supabase 클라이언트

#### 3.2.1 테스트 준비
```typescript
describe('UI 기반 업무플로우 무결성 테스트', () => {
  beforeAll(async () => {
    // 1. 사용자 계정을 제외한 모든 데이터 삭제
    await cleanAllDataExceptUsers();
    
    // 2. 관리자로 로그인
    await page.goto('/ko');
    await page.fill('input[type="email"]', 'admin@yuandi.com');
    await page.fill('input[type="password"]', 'yuandi123!');
    await page.click('button[type="submit"]');
    await page.waitForURL('**/dashboard');
  });
```

#### 3.2.2 제품입고 단계 검증 (UI 사용)

```typescript
  it('UI를 통한 제품입고 및 무결성 검증', async () => {
    // 1. 초기 상태 확인 (UI에서)
    await page.goto('/ko/inventory');
    const initialStockText = await page.locator('.stock-count').textContent();
    const initialStock = parseInt(initialStockText || '0');
    
    // 2. UI를 통한 제품입고 (SQL 사용 금지)
    await page.click('button:has-text("재고 입고")');
    await page.fill('input[name="productName"]', '테스트상품001');
    await page.fill('input[name="quantity"]', '1'); // 1개만 입력
    await page.fill('input[name="costCNY"]', '100');
    await page.fill('input[name="supplier"]', '중국공급업체A');
    await page.click('button:has-text("입고 처리")');
    
    // 3. 즉시 무결성 검증
    await page.waitForTimeout(1000); // UI 업데이트 대기
    const updatedStockText = await page.locator('.stock-count').textContent();
    const updatedStock = parseInt(updatedStockText || '0');
    
    expect(updatedStock).toBe(initialStock + 1);
    
    // 4. 출납장부 확인 (UI에서)
    await page.goto('/ko/cashbook');
    const lastTransaction = await page.locator('tr:last-child').textContent();
    expect(lastTransaction).toContain('입고');
    expect(updatedStock).toBe(initialStock + 100);
    
    // 4. 출납장부 반영 검증
    const cashbookEntries = await getCashbookEntries({
      type: 'inbound',
      productId: 'PROD-001'
    });
    
    expect(cashbookEntries).toHaveLength(1);
    expect(cashbookEntries[0].amount).toBe(-902500); // 지출
    expect(cashbookEntries[0].description).toContain('제품입고');
    expect(cashbookEntries[0].productId).toBe('PROD-001');
    
    // 5. 출납장부 잔액 검증
    const updatedCashbookBalance = await getCashbookBalance();
    expect(updatedCashbookBalance).toBe(initialCashbookBalance - 902500);
  });
  
  it('제품입고 시 환율 적용 정확성 검증', async () => {
    const inboundData = {
      productId: 'PROD-002',
      quantity: 50,
      costCNY: 3000,
      exchangeRate: 182.30,
      totalCostKRW: 547500 // 3000 * 182.30
    };
    
    await createInbound(inboundData);
    
    // 환율 적용된 금액이 정확한지 검증
    const cashbookEntry = await getCashbookEntries({
      type: 'inbound',
      productId: 'PROD-002'
    })[0];
    
    expect(cashbookEntry.amount).toBe(-547500);
    expect(cashbookEntry.exchangeRate).toBe(182.30);
    expect(cashbookEntry.originalAmountCNY).toBe(3000);
  });
});
```

### 3.3 주문생성 단계 검증

```typescript
describe('주문생성 데이터 무결성 테스트', () => {
  it('주문생성 시 재고 감소 및 출납장부 반영', async () => {
    // 1. 초기 상태 설정
    await createInbound({
      productId: 'PROD-001',
      quantity: 100,
      costCNY: 5000,
      exchangeRate: 180.50
    });
    
    const initialStock = await getProductStock('PROD-001');
    const initialCashbookBalance = await getCashbookBalance();
    
    // 2. 주문 생성
    const orderData = {
      customerName: '홍길동',
      customerPhone: '010-1234-5678',
      pccc: 'P123456789012',
      shippingAddress: '서울시 강남구 테헤란로 123',
      items: [
        {
          productId: 'PROD-001',
          productName: 'iPhone 15',
          quantity: 2,
          price: 1200000 // 판매가
        }
      ],
      totalAmount: 2400000,
      shippingFee: 3000
    };
    
    const order = await createOrder(orderData);
    
    // 3. 재고 감소 검증
    const updatedStock = await getProductStock('PROD-001');
    expect(updatedStock).toBe(initialStock - 2);
    
    // 4. 출납장부 매출 반영 검증
    const salesEntries = await getCashbookEntries({
      type: 'sales',
      orderId: order.id
    });
    
    expect(salesEntries).toHaveLength(1);
    expect(salesEntries[0].amount).toBe(2400000); // 수입
    expect(salesEntries[0].description).toContain('주문매출');
    expect(salesEntries[0].orderId).toBe(order.id);
    
    // 5. 출납장부 잔액 검증
    const updatedCashbookBalance = await getCashbookBalance();
    expect(updatedCashbookBalance).toBe(initialCashbookBalance + 2400000);
  });
  
  it('주문생성 시 재고 부족 시 주문 실패', async () => {
    // 재고 부족 상황 설정
    await createInbound({
      productId: 'PROD-001',
      quantity: 1, // 재고 1개만
      costCNY: 5000,
      exchangeRate: 180.50
    });
    
    const initialStock = await getProductStock('PROD-001');
    const initialCashbookBalance = await getCashbookBalance();
    
    // 재고보다 많은 수량으로 주문 시도
    try {
      await createOrder({
        customerName: '홍길동',
        items: [
          {
            productId: 'PROD-001',
            quantity: 5, // 재고보다 많은 수량
            price: 1200000
          }
        ]
      });
    } catch (error) {
      expect(error.message).toContain('재고 부족');
    }
    
    // 재고와 출납장부가 변경되지 않았는지 검증
    const finalStock = await getProductStock('PROD-001');
    const finalCashbookBalance = await getCashbookBalance();
    
    expect(finalStock).toBe(initialStock);
    expect(finalCashbookBalance).toBe(initialCashbookBalance);
  });
});
```

### 3.4 환불처리 단계 검증

```typescript
describe('환불처리 데이터 무결성 테스트', () => {
  it('환불처리 시 재고복구 및 출납장부 반영', async () => {
    // 1. 주문 생성 및 완료
    const order = await createOrder({
      customerName: '홍길동',
      items: [{ productId: 'PROD-001', quantity: 2, price: 1200000 }]
    });
    
    await createShipment({
      orderId: order.id,
      courierCompany: 'CJ대한통운',
      trackingNumber: 'TRK123456789',
      shippingFee: 5000
    });
    
    await completeOrder(order.id);
    
    const initialStock = await getProductStock('PROD-001');
    const initialCashbookBalance = await getCashbookBalance();
    
    // 2. 환불 처리
    const refundData = {
      orderId: order.id,
      reason: '고객 요청',
      refundAmount: 1200000,
      refundFee: 1000 // 환불 수수료
    };
    
    await processRefund(refundData);
    
    // 3. 주문 상태 변경 검증
    const refundedOrder = await getOrder(order.id);
    expect(refundedOrder.status).toBe('refunded');
    expect(refundedOrder.refundedAt).toBeDefined();
    expect(refundedOrder.refundReason).toBe('고객 요청');
    
    // 4. 재고 복구 검증
    const updatedStock = await getProductStock('PROD-001');
    expect(updatedStock).toBe(initialStock + 2);
    
    // 5. 출납장부 환불 반영 검증
    const refundEntries = await getCashbookEntries({
      type: 'refund',
      orderId: order.id
    });
    
    expect(refundEntries).toHaveLength(1);
    expect(refundEntries[0].amount).toBe(-1200000); // 지출 (환불)
    expect(refundEntries[0].description).toContain('환불');
    expect(refundEntries[0].orderId).toBe(order.id);
    
    // 6. 출납장부 잔액 검증
    const updatedCashbookBalance = await getCashbookBalance();
    expect(updatedCashbookBalance).toBe(initialCashbookBalance - 1200000);
  });
});
```

### 3.5 전체 업무플로우 통합 테스트

```typescript
describe('완전한 업무플로우 데이터 무결성 테스트', () => {
  it('제품입고 → 주문 → 배송 → 완료 → 환불 전체 플로우', async () => {
    // 1. 초기 상태
    const initialStock = await getProductStock('PROD-001');
    const initialCashbookBalance = await getCashbookBalance();
    
    // 2. 제품입고
    await createInbound({
      productId: 'PROD-001',
      quantity: 100,
      costCNY: 5000,
      exchangeRate: 180.50,
      totalCostKRW: 902500
    });
    
    // 3. 주문 생성
    const order = await createOrder({
      customerName: '홍길동',
      items: [{ productId: 'PROD-001', quantity: 2, price: 1200000 }]
    });
    
    // 4. 송장 입력
    await createShipment({
      orderId: order.id,
      courierCompany: 'CJ대한통운',
      trackingNumber: 'TRK123456789',
      shippingFee: 5000
    });
    
    // 5. 완료 처리
    await completeOrder(order.id);
    
    // 6. 환불 처리
    await processRefund({
      orderId: order.id,
      reason: '고객 요청',
      refundAmount: 1200000,
      shippingRefund: 5000
    });
    
    // 7. 최종 상태 검증
    const finalStock = await getProductStock('PROD-001');
    const finalCashbookBalance = await getCashbookBalance();
    
    // 재고는 원래대로 복구
    expect(finalStock).toBe(initialStock);
    
    // 출납장부 잔액 계산
    const expectedBalance = initialCashbookBalance 
      - 902500  // 제품입고 비용
      + 1200000 // 주문 매출
      - 5000    // 배송비
      - 1200000 // 환불
      + 5000;   // 배송비 환불
    
    expect(finalCashbookBalance).toBe(expectedBalance);
    
    // 8. 모든 출납장부 항목 검증
    const allEntries = await getCashbookEntries({ orderId: order.id });
    expect(allEntries).toHaveLength(4); // 매출, 배송비, 환불, 배송비환불
    
    // 9. 주문 상태 최종 확인
    const finalOrder = await getOrder(order.id);
    expect(finalOrder.status).toBe('refunded');
  });
});
```

---

## 4. 포괄적 테스트 시나리오

### 4.1 유닛 테스트

#### 도메인 모델 테스트
- [x] **Product 모델**
  - SKU 생성 로직 (한국어/영어 지원)
  - 상품 유효성 검증
  - 재고 관리 기능
  - 가격 계산 로직

- [x] **Order 모델**
  - 주문번호 생성 (날짜 기반)
  - 주문 유효성 검증
  - 상태 전환 로직
  - 환불 처리

- [ ] **Address 모델** (신규 필요)
  - 주소 유효성 검증
  - 우편번호 형식 검증
  - 특수 배송 지역 검증

- [ ] **ExchangeRate 모델** (신규 필요)
  - 환율 데이터 유효성
  - 환율 계산 로직
  - 캐시 만료 처리

#### 서비스 레이어 테스트
- [x] **기존 서비스들**
  - PCCC 서비스
  - 스토리지 서비스
  - Excel 내보내기 서비스
  - 주소 서비스
  - 재고 서비스

- [ ] **환율 서비스** (신규 필요)
  - 한국수출입은행 API 연동
  - 환율 캐싱 로직
  - 환율 업데이트 스케줄링
  - API 실패 시 폴백 처리

- [ ] **우편번호 서비스** (신규 필요)
  - 다음 우편번호 API 연동
  - 주소 검색 기능
  - 주소 정규화
  - API 실패 시 폴백

### 4.2 통합 테스트

#### 외부 API 통합 테스트

```typescript
describe('환율 API 통합 테스트', () => {
  it('한국수출입은행 API 정상 호출', async () => {
    // API 키 유효성 검증
    // 응답 데이터 형식 검증
    // 에러 처리 검증
  });
  
  it('API 실패 시 캐시된 데이터 사용', async () => {
    // 네트워크 오류 시나리오
    // 캐시된 환율 사용 확인
  });
  
  it('주말/공휴일 환율 처리', async () => {
    // 최근 영업일 환율 조회
    // 데이터 일관성 검증
  });
});

describe('우편번호 API 통합 테스트', () => {
  it('다음 우편번호 API 정상 호출', async () => {
    // 스크립트 로딩 검증
    // 주소 검색 기능 검증
    // 응답 데이터 파싱 검증
  });
  
  it('API 로딩 실패 시 폴백 처리', async () => {
    // 스크립트 로딩 실패 시나리오
    // 수동 입력 폴백 확인
  });
});
```

#### 데이터베이스 통합 테스트

```typescript
describe('환율 데이터베이스 통합', () => {
  it('환율 데이터 저장 및 조회', async () => {
    // 환율 데이터 저장
    // 캐시 테이블 업데이트
    // 조회 성능 검증
  });
  
  it('환율 데이터 일관성', async () => {
    // 중복 데이터 방지
    // 트랜잭션 롤백
    // 데이터 무결성 검증
  });
});
```

### 4.3 E2E 테스트

#### 사용자 시나리오 테스트

```typescript
test('완전한 주문 생성 플로우', async ({ page }) => {
  // 1. 로그인
  // 2. 주문 생성 페이지 이동
  // 3. 고객 정보 입력 (우편번호 API 사용)
  // 4. 상품 선택 (환율 적용 가격 표시)
  // 5. 주문 생성
  // 6. 주문 확인
});

test('재고 입고 및 환율 적용', async ({ page }) => {
  // 1. 중국 원가 입력
  // 2. 환율 조회 및 적용
  // 3. 한국 판매가 계산
  // 4. 재고 입고 처리
});
```

#### 다국어 지원 E2E

```typescript
test('다국어 전환 및 데이터 일관성', async ({ page }) => {
  // 1. 한국어로 주문 생성
  // 2. 중국어로 전환
  // 3. 데이터 일관성 확인
  // 4. 환율 표시 확인
});
```

#### 역할 기반 접근 E2E

```typescript
test('관리자 전용 환율 관리', async ({ page }) => {
  // 1. order_manager로 로그인
  // 2. 환율 관리 페이지 접근 시도
  // 3. 접근 거부 확인
  // 4. admin으로 로그인
  // 5. 환율 관리 기능 사용 확인
});
```

---

## 5. 대용량 데이터 무결성 테스트

### 5.1 UI 기반 대규모 데이터 입력 절차

#### 5.1.1 순차적 대규모 입력 프로세스

```typescript
describe('대규모 데이터 순차 입력 테스트', () => {
  let totalProducts = 0;
  let totalOrders = 0;
  let totalShipments = 0;
  let totalCompleted = 0;
  let totalRefunds = 0;

  beforeAll(async () => {
    // 사용자 계정 제외 모든 데이터 삭제
    await cleanAllDataExceptUsers();
    console.log('✅ 데이터베이스 초기화 완료');
  });

  it('상품 2000종 순차 입력 및 검증', async () => {
    for (let i = 1; i <= 2000; i++) {
      // 1. UI를 통한 상품 입력
      await page.goto('/ko/inventory');
      await page.click('button:has-text("상품 등록")');
      await page.fill('input[name="productName"]', `상품${i.toString().padStart(4, '0')}`);
      await page.fill('input[name="sku"]', `SKU-${i.toString().padStart(4, '0')}`);
      await page.fill('input[name="costCNY"]', Math.floor(Math.random() * 1000 + 100).toString());
      await page.fill('input[name="sellingPrice"]', Math.floor(Math.random() * 50000 + 10000).toString());
      await page.click('button:has-text("등록")');
      
      // 2. 즉시 무결성 검증
      await page.waitForSelector(`.product-row:has-text("SKU-${i.toString().padStart(4, '0')}")`);
      totalProducts++;
      
      // 3. 50개마다 전체 검증
      if (i % 50 === 0) {
        const productCount = await page.locator('.product-row').count();
        expect(productCount).toBe(i);
        console.log(`✅ ${i}개 상품 등록 완료 및 검증됨`);
      }
    }
    expect(totalProducts).toBe(2000);
  });

  it('주문 2000개 순차 생성 및 검증', async () => {
    for (let i = 1; i <= 2000; i++) {
      // 1. UI를 통한 주문 생성
      await page.goto('/ko/orders');
      await page.click('button:has-text("주문 생성")');
      
      // 고객 정보 입력
      await page.fill('input[name="customerName"]', `고객${i.toString().padStart(4, '0')}`);
      await page.fill('input[name="phoneNumber"]', `010-${Math.floor(Math.random() * 9000 + 1000)}-${Math.floor(Math.random() * 9000 + 1000)}`);
      
      // 상품 선택 (랜덤)
      const productIndex = Math.floor(Math.random() * totalProducts) + 1;
      await page.selectOption('select[name="productId"]', { index: productIndex });
      await page.fill('input[name="quantity"]', Math.floor(Math.random() * 5 + 1).toString());
      
      await page.click('button:has-text("주문 생성")');
      
      // 2. 즉시 무결성 검증
      await page.waitForSelector('.order-success-message');
      totalOrders++;
      
      // 재고 감소 확인
      await page.goto('/ko/inventory');
      const stockElement = await page.locator(`.stock-row:nth-child(${productIndex}) .stock-count`);
      const currentStock = parseInt(await stockElement.textContent() || '0');
      expect(currentStock).toBeGreaterThanOrEqual(0);
      
      // 3. 100개마다 전체 검증
      if (i % 100 === 0) {
        await page.goto('/ko/orders');
        const orderCount = await page.locator('.order-row').count();
        expect(orderCount).toBeGreaterThanOrEqual(i);
        console.log(`✅ ${i}개 주문 생성 완료 및 검증됨`);
      }
    }
    expect(totalOrders).toBe(2000);
  });

  it('배송 1000개 처리 및 검증', async () => {
    for (let i = 1; i <= 1000; i++) {
      // 1. PAID 상태 주문 찾기
      await page.goto('/ko/orders');
      const paidOrder = await page.locator('.order-row:has-text("결제완료")').first();
      
      if (await paidOrder.isVisible()) {
        // 2. UI를 통한 배송 처리
        await paidOrder.click();
        await page.click('button:has-text("배송 정보 입력")');
        await page.fill('input[name="trackingNumber"]', `TRACK-${i.toString().padStart(4, '0')}`);
        await page.selectOption('select[name="carrier"]', 'CJ대한통운');
        await page.click('button:has-text("배송 시작")');
        
        // 3. 즉시 상태 변경 검증
        await page.waitForSelector('.status-badge:has-text("배송중")');
        totalShipments++;
      }
      
      // 4. 50개마다 전체 검증
      if (i % 50 === 0) {
        const shippedCount = await page.locator('.order-row:has-text("배송중")').count();
        expect(shippedCount).toBeGreaterThanOrEqual(totalShipments);
        console.log(`✅ ${totalShipments}개 배송 처리 완료 및 검증됨`);
      }
    }
    expect(totalShipments).toBeGreaterThanOrEqual(1000);
  });

  it('배송완료 1000개 처리 및 검증', async () => {
    for (let i = 1; i <= 1000; i++) {
      // 1. 배송중 상태 주문 찾기
      await page.goto('/ko/shipments');
      const shippingOrder = await page.locator('.shipment-row:has-text("배송중")').first();
      
      if (await shippingOrder.isVisible()) {
        // 2. UI를 통한 배송완료 처리
        await shippingOrder.click();
        await page.click('button:has-text("배송 완료")');
        await page.click('button:has-text("확인")'); // 확인 다이얼로그
        
        // 3. 즉시 상태 변경 검증
        await page.waitForSelector('.status-badge:has-text("배송완료")');
        totalCompleted++;
      }
      
      // 4. 50개마다 전체 검증
      if (i % 50 === 0) {
        const completedCount = await page.locator('.order-row:has-text("배송완료")').count();
        expect(completedCount).toBeGreaterThanOrEqual(totalCompleted);
        console.log(`✅ ${totalCompleted}개 배송완료 처리 및 검증됨`);
      }
    }
    expect(totalCompleted).toBeGreaterThanOrEqual(1000);
  });

  it('환불 100개 처리 및 검증', async () => {
    for (let i = 1; i <= 100; i++) {
      // 1. 배송완료 상태 주문 찾기
      await page.goto('/ko/orders');
      const completedOrder = await page.locator('.order-row:has-text("배송완료")').first();
      
      if (await completedOrder.isVisible()) {
        const orderId = await completedOrder.getAttribute('data-order-id');
        
        // 2. UI를 통한 환불 처리
        await completedOrder.click();
        await page.click('button:has-text("환불 처리")');
        await page.fill('textarea[name="refundReason"]', `환불 사유 ${i}`);
        await page.fill('input[name="refundAmount"]', '전액환불');
        await page.click('button:has-text("환불 승인")');
        
        // 3. 즉시 검증
        await page.waitForSelector('.status-badge:has-text("환불완료")');
        totalRefunds++;
        
        // 재고 복구 확인
        await page.goto('/ko/inventory');
        // 재고가 증가했는지 확인하는 로직
        
        // 출납장부 환불 기록 확인
        await page.goto('/ko/cashbook');
        const refundEntry = await page.locator(`tr:has-text("환불"):has-text("${orderId}")`);
        expect(await refundEntry.isVisible()).toBe(true);
      }
      
      // 4. 10개마다 전체 검증
      if (i % 10 === 0) {
        const refundCount = await page.locator('.order-row:has-text("환불완료")').count();
        expect(refundCount).toBeGreaterThanOrEqual(totalRefunds);
        console.log(`✅ ${totalRefunds}개 환불 처리 완료 및 검증됨`);
      }
    }
    expect(totalRefunds).toBeGreaterThanOrEqual(100);
  });

  afterAll(async () => {
    console.log('📊 최종 테스트 결과:');
    console.log(`- 상품 등록: ${totalProducts}개`);
    console.log(`- 주문 생성: ${totalOrders}개`);
    console.log(`- 배송 처리: ${totalShipments}개`);
    console.log(`- 배송 완료: ${totalCompleted}개`);
    console.log(`- 환불 처리: ${totalRefunds}개`);
  });
});
```

### 5.2 성능 모니터링 및 검증

```typescript
describe('대규모 데이터 처리 성능 검증', () => {
  it('페이지 로딩 성능 (2000개 데이터)', async () => {
    const startTime = Date.now();
    await page.goto('/ko/orders');
    await page.waitForLoadState('networkidle');
    const loadTime = Date.now() - startTime;
    
    expect(loadTime).toBeLessThan(3000); // 3초 이내
    console.log(`✅ 주문 목록 (2000개) 로딩 시간: ${loadTime}ms`);
  });

  it('검색 및 필터링 성능', async () => {
    await page.goto('/ko/inventory');
    
    const startTime = Date.now();
    await page.fill('input[name="search"]', '상품0500');
    await page.waitForSelector('.product-row:has-text("상품0500")');
    const searchTime = Date.now() - startTime;
    
    expect(searchTime).toBeLessThan(1000); // 1초 이내
    console.log(`✅ 검색 응답 시간: ${searchTime}ms`);
  });

  it('페이지네이션 성능', async () => {
    await page.goto('/ko/orders');
    
    const startTime = Date.now();
    await page.click('button:has-text("다음 페이지")');
    await page.waitForLoadState('networkidle');
    const paginationTime = Date.now() - startTime;
    
    expect(paginationTime).toBeLessThan(1000); // 1초 이내
    console.log(`✅ 페이지네이션 응답 시간: ${paginationTime}ms`);
  });
});
```

### 5.1 테스트 초기화

#### 데이터베이스 초기화 스크립트

```sql
-- 테스트 시작 전 데이터 정리 (사용자 계정 제외)
-- 사용자 계정은 유지하고 나머지 모든 데이터 삭제

-- 1. 출납장부 거래 내역 삭제 (초기 자금 제외)
DELETE FROM cashbook_transactions 
WHERE type != 'initial';

-- 2. 환불 데이터 삭제
DELETE FROM refunds;

-- 3. 배송 데이터 삭제
DELETE FROM shipments;

-- 4. 주문 데이터 삭제
DELETE FROM orders;

-- 5. 재고 입출고 내역 삭제
DELETE FROM inventory_movements;

-- 6. 상품 데이터 삭제
DELETE FROM products;

-- 7. 공급업체 데이터 삭제
DELETE FROM suppliers;

-- 8. 환율 데이터 삭제 (기본 환율 제외)
DELETE FROM exchange_rates 
WHERE source != 'default';

-- 9. 초기 자금 설정 (1억원)
INSERT INTO cashbook_transactions (type, amount, description, balance)
VALUES ('initial', 100000000, '테스트 초기 자금', 100000000);

-- 10. 기본 환율 설정
INSERT INTO exchange_rates (date, base_currency, target_currency, rate, source, is_active)
VALUES (CURRENT_DATE, 'CNY', 'KRW', 180.50, 'default', true);
```

### 5.2 UI 기반 단계별 데이터 생성

#### 1단계: 상품입고 (2,000종류 이상) - UI 기반

```typescript
export class UIProductInboundTester {
  private page: any;
  private validator: DatabaseIntegrityValidator;

  constructor(page: any) {
    this.page = page;
    this.validator = new DatabaseIntegrityValidator();
  }

  /**
   * 2,000종류 이상 상품입고 실행 (UI 기반)
   */
  async executeProductInboundTest(): Promise<void> {
    console.log('📦 1단계: UI 기반 상품입고 테스트 시작 (2,000종류)');

    const categories = ['ELEC', 'FASHION', 'HOME', 'BEAUTY', 'SPORTS'];
    const brands = ['Apple', 'Samsung', 'Huawei', 'Xiaomi', 'Oppo', 'Vivo', 'OnePlus', 'Realme'];
    const colors = ['Black', 'White', 'Silver', 'Gold', 'Blue', 'Red', 'Green', 'Purple'];

    let successCount = 0;
    let errorCount = 0;

    for (let i = 1; i <= 2000; i++) {
      try {
        // 상품 데이터 생성
        const productData = this.generateProductData(i, categories, brands, colors);
        
        // UI를 통한 상품입고 실행
        await this.createProductInboundViaUI(productData);
        
        // 무결성 검증 (매 100개마다)
        if (i % 100 === 0) {
          const isValid = await this.validator.validateInventoryIntegrity(productData.productId);
          if (!isValid) {
            throw new Error(`재고 무결성 검증 실패: ${productData.productId}`);
          }
          
          console.log(`✅ ${i}개 상품입고 완료 및 무결성 검증 통과`);
        }
        
        successCount++;
        
      } catch (error) {
        console.error(`❌ 상품 ${i} 입고 실패:`, error.message);
        errorCount++;
      }
    }

    // 최종 무결성 검증
    const finalValidation = await this.validator.validateSystemIntegrity();
    if (!finalValidation.overall) {
      throw new Error('최종 무결성 검증 실패');
    }

    console.log(`📊 상품입고 테스트 완료: 성공 ${successCount}개, 실패 ${errorCount}개`);
  }

  /**
   * UI를 통한 상품입고 실행
   */
  private async createProductInboundViaUI(data: any): Promise<void> {
    // 1. 재고 관리 페이지로 이동
    await this.page.click('a:has-text("재고 관리")');
    await this.page.waitForURL('**/inventory');

    // 2. 입고 버튼 클릭
    await this.page.click('button:has-text("입고")');
    await this.page.waitForSelector('h2:has-text("제품 입고")');

    // 3. 상품 정보 입력
    await this.page.fill('input[placeholder*="제품명"]', data.name);
    await this.page.fill('input[placeholder*="SKU"]', data.sku);
    await this.page.selectOption('select[name="category"]', data.category);
    await this.page.fill('input[placeholder*="브랜드"]', data.brand);
    await this.page.fill('input[placeholder*="색상"]', data.color);
    await this.page.fill('input[placeholder*="모델"]', data.model);
    await this.page.fill('input[placeholder*="중국 원가"]', data.costCNY.toString());
    await this.page.fill('input[placeholder*="수량"]', data.quantity.toString());
    await this.page.selectOption('select[name="supplier"]', data.supplier);
    await this.page.fill('input[placeholder*="송장번호"]', data.invoiceNumber);

    // 4. 환율 자동 적용 확인
    await this.page.waitForSelector('text=현재 환율');
    await this.page.waitForSelector('text=180.50');
    
    // 5. 입고 실행
    await this.page.click('button:has-text("입고 실행")');
    
    // 6. 성공 메시지 확인
    await this.page.waitForSelector('text=입고 완료');
    
    // 7. 모달 닫기
    await this.page.click('button:has-text("닫기")');
    
    // 8. 재고 목록에서 상품 확인
    await this.page.waitForSelector(`text=${data.name}`);
  }
}
```

#### 2단계: 주문 생성 (2,000개 이상) - UI 기반

```typescript
export class UIOrderCreationTester {
  private page: any;
  private validator: DatabaseIntegrityValidator;

  constructor(page: any) {
    this.page = page;
    this.validator = new DatabaseIntegrityValidator();
  }

  /**
   * 2,000개 이상 주문 생성 실행 (UI 기반)
   */
  async executeOrderCreationTest(): Promise<void> {
    console.log('🛒 2단계: UI 기반 주문 생성 테스트 시작 (2,000개)');

    let successCount = 0;
    let errorCount = 0;

    for (let i = 1; i <= 2000; i++) {
      try {
        // 주문 데이터 생성
        const orderData = this.generateOrderData(i);
        
        // UI를 통한 주문 생성 실행
        await this.createOrderViaUI(orderData);
        
        // 무결성 검증 (매 100개마다)
        if (i % 100 === 0) {
          const isValid = await this.validator.validateSystemIntegrity();
          if (!isValid.overall) {
            throw new Error(`시스템 무결성 검증 실패: 주문 ${i}`);
          }
          
          console.log(`✅ ${i}개 주문 생성 완료 및 무결성 검증 통과`);
        }
        
        successCount++;
        
      } catch (error) {
        console.error(`❌ 주문 ${i} 생성 실패:`, error.message);
        errorCount++;
      }
    }

    // 최종 무결성 검증
    const finalValidation = await this.validator.validateSystemIntegrity();
    if (!finalValidation.overall) {
      throw new Error('최종 무결성 검증 실패');
    }

    console.log(`📊 주문 생성 테스트 완료: 성공 ${successCount}개, 실패 ${errorCount}개`);
  }

  /**
   * UI를 통한 주문 생성 실행
   */
  private async createOrderViaUI(data: any): Promise<void> {
    // 1. 주문 관리 페이지로 이동
    await this.page.click('a:has-text("주문 관리")');
    await this.page.waitForURL('**/orders');

    // 2. 주문 생성 버튼 클릭
    await this.page.click('button:has-text("주문 생성")');
    await this.page.waitForSelector('h2:has-text("새 주문 생성")');

    // 3. 고객 정보 입력
    await this.page.fill('input[placeholder*="고객명"]', data.customerName);
    await this.page.fill('input[placeholder*="전화번호"]', data.customerPhone);
    await this.page.fill('input[placeholder*="이메일"]', data.customerEmail);
    await this.page.fill('input[placeholder*="PCCC"]', data.pccc);

    // 4. 주소 입력 (우편번호 API 사용)
    await this.page.click('button:has-text("우편번호 검색")');
    await this.page.waitForSelector('#daum-postcode-container');
    
    // 모의 주소 입력 (실제 API 대신)
    await this.page.fill('input[placeholder*="우편번호"]', data.shippingPostalCode);
    await this.page.fill('input[placeholder*="주소"]', data.shippingAddress);
    await this.page.fill('input[placeholder*="상세주소"]', data.shippingAddressDetail);

    // 5. 상품 추가
    await this.page.click('button:has-text("상품 추가")');
    await this.page.fill('input[placeholder*="상품명"]', data.items[0].productName);
    await this.page.fill('input[placeholder*="수량"]', data.items[0].quantity.toString());
    await this.page.fill('input[placeholder*="단가"]', data.items[0].price.toString());

    // 6. 환율 적용 확인
    await this.page.waitForSelector('text=현재 환율');
    await this.page.waitForSelector('text=180.50');

    // 7. 주문 생성
    await this.page.click('button:has-text("생성")');
    
    // 8. 성공 메시지 확인
    await this.page.waitForSelector('text=주문 생성 완료');
    
    // 9. 모달 닫기
    await this.page.click('button:has-text("닫기")');
    
    // 10. 주문 목록에서 주문 확인
    await this.page.waitForSelector(`text=${data.customerName}`);
  }
}
```

### 5.3 데이터 무결성 검증 도구

```typescript
export class DatabaseIntegrityValidator {
  
  // 재고 무결성 검증
  async validateInventoryIntegrity(productId: string): Promise<boolean> {
    const currentStock = await getProductStock(productId);
    const inboundTotal = await getTotalInbound(productId);
    const outboundTotal = await getTotalOutbound(productId);
    
    const expectedStock = inboundTotal - outboundTotal;
    return currentStock === expectedStock;
  }
  
  // 출납장부 무결성 검증
  async validateCashbookIntegrity(): Promise<boolean> {
    const currentBalance = await getCashbookBalance();
    const calculatedBalance = await calculateCashbookBalance();
    
    return Math.abs(currentBalance - calculatedBalance) < 0.01; // 소수점 오차 허용
  }
  
  // 주문 상태 무결성 검증
  async validateOrderStatusIntegrity(orderId: string): Promise<boolean> {
    const order = await getOrder(orderId);
    const shipments = await getShipments(orderId);
    const refunds = await getRefunds(orderId);
    
    // 주문 상태와 관련 데이터 일치성 검증
    if (order.status === 'shipped' && shipments.length === 0) return false;
    if (order.status === 'refunded' && refunds.length === 0) return false;
    
    return true;
  }
  
  // 전체 시스템 무결성 검증
  async validateSystemIntegrity(): Promise<{
    inventory: boolean;
    cashbook: boolean;
    orders: boolean;
    overall: boolean;
  }> {
    const inventoryValid = await this.validateInventoryIntegrity('PROD-001');
    const cashbookValid = await this.validateCashbookIntegrity();
    const ordersValid = await this.validateOrderStatusIntegrity('ORDER-001');
    
    return {
      inventory: inventoryValid,
      cashbook: cashbookValid,
      orders: ordersValid,
      overall: inventoryValid && cashbookValid && ordersValid
    };
  }
}
```

### 5.4 UI 기반 통합 테스트 실행

```typescript
export class UILargeScaleDataIntegrityTest {
  private page: any;
  private initializer: TestDataInitializer;
  private inboundTester: UIProductInboundTester;
  private orderTester: UIOrderCreationTester;
  private shipmentTester: UIShipmentTester;
  private deliveryTester: UIDeliveryCompletionTester;
  private refundTester: UIRefundTester;

  constructor(page: any) {
    this.page = page;
    this.initializer = new TestDataInitializer();
    this.inboundTester = new UIProductInboundTester(page);
    this.orderTester = new UIOrderCreationTester(page);
    this.shipmentTester = new UIShipmentTester(page);
    this.deliveryTester = new UIDeliveryCompletionTester(page);
    this.refundTester = new UIRefundTester(page);
  }

  /**
   * UI 기반 전체 대용량 데이터 무결성 테스트 실행
   */
  async executeFullTest(): Promise<void> {
    const startTime = Date.now();
    
    try {
      console.log('🚀 UI 기반 대용량 데이터 무결성 테스트 시작');
      console.log('=' .repeat(60));

      // 1. 관리자 로그인
      await this.loginAsAdmin();

      // 2. 테스트 환경 초기화 (UI를 통한 데이터 정리)
      await this.initializeTestEnvironmentViaUI();

      // 3. 1단계: 상품입고 (2,000종류) - UI 기반
      await this.inboundTester.executeProductInboundTest();

      // 4. 2단계: 주문 생성 (2,000개) - UI 기반
      await this.orderTester.executeOrderCreationTest();

      // 5. 3단계: 배송 처리 (1,000개) - UI 기반
      await this.shipmentTester.executeShipmentTest();

      // 6. 4단계: 배송완료 처리 (1,000개) - UI 기반
      await this.deliveryTester.executeDeliveryCompletionTest();

      // 7. 5단계: 환불 처리 (100개) - UI 기반
      await this.refundTester.executeRefundTest();

      // 8. 최종 무결성 검증
      console.log('🔍 최종 무결성 검증 중...');
      const finalValidation = await this.validateFinalIntegrityViaUI();
      
      if (finalValidation.overall) {
        console.log('✅ 모든 테스트 통과! 데이터 무결성 검증 완료');
      } else {
        throw new Error('최종 무결성 검증 실패');
      }

      const endTime = Date.now();
      const totalTime = (endTime - startTime) / 1000;
      
      console.log('=' .repeat(60));
      console.log(`🎉 UI 기반 대용량 데이터 무결성 테스트 완료!`);
      console.log(`⏱️  총 소요 시간: ${totalTime.toFixed(2)}초`);
      console.log(`📊 처리된 데이터:`);
      console.log(`   - 상품입고: 2,000종류 (UI 기반)`);
      console.log(`   - 주문: 2,000개 (UI 기반)`);
      console.log(`   - 배송: 1,000개 (UI 기반)`);
      console.log(`   - 배송완료: 1,000개 (UI 기반)`);
      console.log(`   - 환불: 100개 (UI 기반)`);

    } catch (error) {
      console.error('❌ 테스트 실패:', error);
      throw error;
    }
  }
}
```

---

## 6. 테스트 실행 가이드

### 6.1 E2E 테스트 프레임워크

> **선택 가능**: E2E 테스트는 **Playwright** (권장) 또는 **Puppeteer**를 사용할 수 있습니다.

#### E2E 테스트 프레임워크 선택

##### Option 1: Playwright (권장)
- **크로스 브라우저 지원**: Chrome, Firefox, Safari 동시 테스트
- **강력한 디버깅 도구**: 트레이싱, 스크린샷, 비디오 녹화
- **병렬 실행**: 여러 테스트 동시 실행으로 빠른 피드백
- **실행 방법**:
```bash
# 모든 E2E 테스트 실행
pnpm test:e2e

# 특정 테스트 파일 실행
npx playwright test e2e/orders.spec.ts

# UI 모드로 실행 (시각적 디버깅)
npx playwright test --ui
```

##### Option 2: Puppeteer (간단한 테스트용)
- **Chrome 전용**: Chromium 기반 브라우저만 지원
- **빠른 프로토타이핑**: 독립 실행 가능한 스크립트
- **간단한 자동화**: 복잡한 설정 없이 바로 실행

##### Puppeteer 설치 및 실행
```bash
# Puppeteer 설치 (프로젝트 루트에서)
npm install --save-dev puppeteer

# 또는 독립적으로 실행할 경우
npx puppeteer [script.js]
```

##### 테스트 실행
```bash
# 대량 데이터 UI 테스트 실행
cd my-puppeteer
node test-large-scale-ui.js
```

##### Puppeteer 테스트 특징
- **실제 브라우저 사용**: Chrome 브라우저를 실제로 실행하여 테스트
- **UI 상호작용**: 버튼 클릭, 텍스트 입력 등 실제 사용자 행동 시뮬레이션
- **성능 측정**: 각 작업의 응답 시간 자동 측정
- **시각적 확인**: headless: false 옵션으로 테스트 과정 시각적 확인 가능

##### Puppeteer 설정 옵션
```javascript
const browser = await puppeteer.launch({
    headless: false,                          // 브라우저 표시 여부
    executablePath: '/usr/bin/google-chrome', // 시스템 Chrome 경로
    defaultViewport: { width: 1280, height: 800 },
    args: ['--no-sandbox', '--disable-setuid-sandbox']
});
```

### 6.2 테스트 실행 명령어

#### 유닛 테스트
```bash
# 모든 유닛 테스트 실행
npm run test:unit

# 특정 테스트 파일 실행
npm run test:unit -- domain-models.test.ts

# 감시 모드로 실행
npm run test:watch
```

#### 통합 테스트
```bash
# 모든 통합 테스트 실행
npm run test:integration

# 특정 테스트 파일 실행
npm run test:integration -- order-creation-flow.test.ts
```

#### API 테스트
```bash
# 모든 API 테스트 실행
npm run test:api

# 환율 API 테스트만 실행
npm run test:api -- exchange-rate.test.ts

# 우편번호 API 테스트만 실행
npm run test:api -- postal-code.test.ts
```

#### 업무플로우 테스트
```bash
# 업무플로우 무결성 테스트 실행
npm run test:workflow:integrity

# 특정 단계별 테스트
npm run test:workflow:inbound     # 제품입고 테스트
npm run test:workflow:order       # 주문생성 테스트
npm run test:workflow:shipment    # 송장입력 테스트
npm run test:workflow:completion  # 완료처리 테스트
npm run test:workflow:refund      # 환불처리 테스트

# 전체 플로우 테스트
npm run test:workflow:full
```

#### E2E 테스트
```bash
# 모든 E2E 테스트 실행
npm run test:e2e:all

# 시나리오 테스트만 실행
npm run test:e2e:scenarios

# 성능 테스트만 실행
npm run test:e2e:performance

# 보안 테스트만 실행
npm run test:e2e:security

# 대용량 데이터 테스트
npm run test:e2e:large-scale
```

#### 전체 테스트
```bash
# 모든 Jest 테스트 실행
npm run test:all

# 모든 테스트 실행 (Jest + Playwright)
npm run test && npm run test:e2e:all

# 업무플로우 포함 전체 테스트
npm run test:all && npm run test:e2e:all && npm run test:workflow:all
```

### 6.2 테스트 환경 설정

#### 환경 변수 설정
```bash
# .env.test
KOREA_EXIM_API_KEY=test-api-key
NEXT_PUBLIC_SUPABASE_URL=https://test.supabase.co
NEXT_PUBLIC_SUPABASE_API_KEY=test-public-key
```

#### 테스트 데이터베이스
- 각 테스트 후 자동으로 데이터 정리
- 테스트 격리 보장
- 시드 데이터 사용

### 6.3 테스트 데이터 시드

#### 업무플로우 테스트용 시드 데이터
```sql
-- 제품입고 테스트용 데이터
INSERT INTO products (id, name, sku, cost_cny, on_hand) VALUES
('PROD-001', 'iPhone 15', 'ELEC-iPhone15-Black-Apple-ABC12', 5000, 0),
('PROD-002', 'Galaxy S24', 'ELEC-GalaxyS24-White-Samsung-DEF34', 4000, 0);

-- 초기 출납장부 잔액 설정
INSERT INTO cashbook_transactions (type, amount, description, balance) VALUES
('initial', 10000000, '초기 자금', 10000000);

-- 공급업체 데이터
INSERT INTO suppliers (id, name, contact) VALUES
('SUP-001', '중국공급업체A', 'supplier-a@example.com'),
('SUP-002', '중국공급업체B', 'supplier-b@example.com');
```

#### 환율 테스트 데이터
```sql
-- 테스트용 환율 데이터
INSERT INTO exchange_rates (date, base_currency, target_currency, rate, source)
VALUES 
  ('2024-01-01', 'CNY', 'KRW', 180.50, 'test'),
  ('2024-01-02', 'CNY', 'KRW', 181.20, 'test');
```

#### 주소 테스트 데이터
```sql
-- 테스트용 주소 데이터
INSERT INTO test_addresses (postcode, address, city, state)
VALUES 
  ('12345', '서울시 강남구 테헤란로 123', '서울', '강남구');
```

---

## 7. 성능 및 보안 테스트

### 7.1 성능 테스트

#### API 성능 테스트
```typescript
describe('환율 API 성능 테스트', () => {
  it('환율 조회 응답 시간 < 2초', async () => {
    // 캐시된 데이터 조회 성능
    // API 호출 성능
  });
  
  it('동시 요청 처리', async () => {
    // 100개 동시 요청
    // 응답 시간 분포
    // 에러율 측정
  });
});

describe('우편번호 API 성능 테스트', () => {
  it('주소 검색 응답 시간 < 1초', async () => {
    // 스크립트 로딩 시간
    // 검색 응답 시간
  });
});
```

#### 데이터베이스 성능 테스트
```typescript
describe('환율 데이터베이스 성능', () => {
  it('대량 환율 데이터 조회', async () => {
    // 1년치 환율 데이터
    // 인덱스 성능 검증
    // 쿼리 최적화 확인
  });
});
```

#### 대용량 데이터 처리 테스트
```typescript
describe('대용량 데이터 무결성 테스트', () => {
  it('1000개 제품입고 → 500개 주문 → 100개 환불 처리', async () => {
    // 대용량 데이터로 무결성 테스트
    const products = [];
    const orders = [];
    
    // 1000개 제품입고
    for (let i = 0; i < 1000; i++) {
      const product = await createInbound({
        productId: `PROD-${i.toString().padStart(3, '0')}`,
        quantity: 10,
        costCNY: 1000 + i,
        exchangeRate: 180.50
      });
      products.push(product);
    }
    
    // 500개 주문 생성
    for (let i = 0; i < 500; i++) {
      const order = await createOrder({
        customerName: `고객${i}`,
        items: [{
          productId: `PROD-${(i % 1000).toString().padStart(3, '0')}`,
          quantity: 1,
          price: 200000
        }]
      });
      orders.push(order);
    }
    
    // 100개 환불 처리
    for (let i = 0; i < 100; i++) {
      await processRefund({
        orderId: orders[i].id,
        reason: '고객 요청',
        refundAmount: 200000
      });
    }
    
    // 무결성 검증
    const validator = new DatabaseIntegrityValidator();
    const result = await validator.validateSystemIntegrity();
    
    expect(result.overall).toBe(true);
  });
});
```

### 7.2 보안 테스트

#### API 보안 테스트
```typescript
describe('환율 API 보안 테스트', () => {
  it('API 키 보안', async () => {
    // API 키 노출 방지
    // 요청 제한 검증
  });
  
  it('SQL 인젝션 방지', async () => {
    // 악의적 입력 처리
    // 파라미터 검증
  });
});

describe('우편번호 API 보안 테스트', () => {
  it('XSS 방지', async () => {
    // 스크립트 인젝션 방지
    // 입력값 검증
  });
});
```

#### 데이터 보안 테스트
```typescript
describe('환율 데이터 보안', () => {
  it('민감 데이터 암호화', async () => {
    // API 키 암호화 저장
    // 로그에서 민감 정보 제거
  });
});
```

### 7.3 장애 복구 테스트

#### 외부 API 장애 테스트
```typescript
describe('환율 API 장애 복구', () => {
  it('API 서버 다운 시 폴백', async () => {
    // API 호출 실패
    // 캐시된 데이터 사용
    // 기본값 사용
  });
  
  it('API 응답 지연 시 타임아웃', async () => {
    // 5초 타임아웃 설정
    // 폴백 로직 실행
  });
});

describe('우편번호 API 장애 복구', () => {
  it('스크립트 로딩 실패 시 폴백', async () => {
    // 스크립트 로딩 실패
    // 수동 입력 모드 전환
  });
});
```

### 7.4 모니터링 및 알림 테스트

#### 헬스체크 테스트
```typescript
describe('헬스체크 모니터링', () => {
  it('환율 API 상태 모니터링', async () => {
    // API 응답 시간 측정
    // 상태 보고서 생성
  });
  
  it('우편번호 API 상태 모니터링', async () => {
    // 스크립트 로딩 상태
    // 기능 동작 확인
  });
});
```

#### 알림 시스템 테스트
```typescript
describe('API 장애 알림', () => {
  it('환율 API 장애 시 알림', async () => {
    // API 호출 실패 감지
    // 관리자 알림 발송
  });
});
```

### 7.5 실시간 무결성 모니터링

```typescript
// 실시간 무결성 모니터링
export class IntegrityMonitor {
  async startMonitoring() {
    setInterval(async () => {
      const validator = new DatabaseIntegrityValidator();
      const result = await validator.validateSystemIntegrity();
      
      if (!result.overall) {
        console.error('데이터 무결성 위반 감지:', result);
        // 알림 발송
        await this.sendAlert(result);
      }
    }, 60000); // 1분마다 검증
  }
  
  async sendAlert(result: any) {
    // 슬랙, 이메일 등으로 알림 발송
  }
}
```

---

## 8. CI/CD 통합

### 8.1 GitHub Actions 워크플로우

```yaml
name: Test Suite
on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run test:unit
      - run: npm run test:integration
      - run: npm run test:api

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run build
      - run: npm run test:e2e:all

  workflow-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run test:workflow:integrity
      - run: npm run test:workflow:e2e

  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run test:performance
      - run: npm run test:e2e:performance

  security-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install
      - run: npm run test:security
      - run: npm run test:e2e:security
```

### 8.2 테스트 실행 스크립트 (package.json)

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:unit": "jest --testPathPattern=unit",
    "test:integration": "jest --testPathPattern=integration",
    "test:api": "jest --testPathPattern=api",
    "test:performance": "jest --testPathPattern=performance",
    "test:security": "jest --testPathPattern=security",
    "test:workflow:integrity": "jest --testPathPattern=workflow/integrity",
    "test:workflow:inbound": "jest --testPathPattern=workflow/inbound",
    "test:workflow:order": "jest --testPathPattern=workflow/order",
    "test:workflow:shipment": "jest --testPathPattern=workflow/shipment",
    "test:workflow:completion": "jest --testPathPattern=workflow/completion",
    "test:workflow:refund": "jest --testPathPattern=workflow/refund",
    "test:workflow:full": "jest --testPathPattern=workflow/full",
    "test:e2e": "playwright test",
    "test:e2e:all": "playwright test",
    "test:e2e:scenarios": "playwright test --grep @scenarios",
    "test:e2e:performance": "playwright test --grep @performance",
    "test:e2e:security": "playwright test --grep @security",
    "test:e2e:workflow": "playwright test --grep @workflow",
    "test:e2e:large-scale": "playwright test --grep @large-scale",
    "test:all": "npm run test && npm run test:e2e"
  }
}
```

### 8.3 커버리지 목표

- **유닛 테스트**: 90% 이상
- **통합 테스트**: 80% 이상
- **E2E 테스트**: 주요 시나리오 100%

### 8.4 성능 목표

- **API 응답 시간**: < 2초
- **데이터베이스 쿼리**: < 500ms
- **페이지 로딩**: < 3초
- **동시 요청 처리**: 100개 요청 < 10초

### 8.5 테스트 메트릭 및 리포팅

#### 테스트 메트릭
- 테스트 실행 시간
- 성공/실패율
- 커버리지 비율
- 성능 지표

#### 알림 설정
- 테스트 실패 시 슬랙 알림
- 성능 저하 시 이메일 알림
- 보안 테스트 실패 시 즉시 알림

#### 테스트 리포팅
- Jest 커버리지 리포트
- Playwright HTML 리포트
- 성능 테스트 결과
- 보안 테스트 결과

---

## 문제 해결

### 일반적인 문제
1. **테스트 실패**: 로그 확인 및 환경 변수 설정 검증
2. **API 타임아웃**: 네트워크 상태 및 API 서버 상태 확인
3. **데이터베이스 오류**: 테스트 데이터 정리 및 연결 상태 확인

### 디버깅
```bash
# 상세 로그와 함께 테스트 실행
npm run test:unit -- --verbose

# 특정 테스트만 실행
npm run test:unit -- --testNamePattern="환율 API"

# 커버리지 리포트 생성
npm run test:unit -- --coverage
```

---

## 구현 우선순위

### Phase 1: 핵심 기능 테스트 (1주)
1. 업무플로우 무결성 테스트
2. 환율 API 통합 테스트
3. 우편번호 API 통합 테스트
4. 기본 E2E 시나리오

### Phase 2: 고급 기능 테스트 (1주)
1. 대용량 데이터 무결성 테스트
2. 성능 테스트
3. 보안 테스트
4. 장애 복구 테스트

### Phase 3: 모니터링 및 자동화 (1주)
1. 헬스체크 테스트
2. 알림 시스템 테스트
3. CI/CD 통합
4. 실시간 무결성 모니터링

---

이 통합 테스트 가이드를 통해 YUANDI ERP 시스템의 안정성과 신뢰성을 크게 향상시킬 수 있습니다. 각 테스트는 독립적으로 실행 가능하며, 전체 시스템의 무결성을 보장합니다.
# YUANDI ERP 테스트 가이드

> **작성일**: 2025-01-13  
> **최종 수정**: 2025-01-14  
> **버전**: v1.1  
> **목적**: YUANDI ERP 시스템의 E2E 테스트 시나리오 및 방법 문서화  
> **참조 문서**: PRD v2.0, Database Schema v1.1, 소스 코드 분석

## 📋 목차
1. [테스트 환경](#테스트-환경)
2. [다국어 테스트 요구사항](#다국어-테스트-요구사항)
3. [비즈니스 플로우 테스트 시나리오](#비즈니스-플로우-테스트-시나리오)
4. [폼 테스트 작성 규칙](#폼-테스트-작성-규칙-중요)
5. [테스트 실행 방법](#테스트-실행-방법)
6. [실제 테스트 실행 결과 및 이슈](#실제-테스트-실행-결과-및-이슈)

---

## 테스트 환경

### 배포 환경
- **URL**: https://00-yuandi-erp.vercel.app/
- **호스팅**: Vercel
- **데이터베이스**: Supabase

### 로컬 테스트 환경
- **URL**: http://localhost:8081
- **포트**: 8081 (기본값 3000 대신 사용)
- **환경**: WSL2 + Windows

### 테스트 도구
- **E2E 테스트**: Playwright
- **단위 테스트**: Jest
- **타입 체크**: TypeScript

### 테스트 디렉토리 구조
```
/mnt/d/00.Projects/00.YUANDI-ERP/
├── __tests__/              # Jest 단위/통합 테스트
│   ├── api/               # API 테스트
│   ├── integration/       # 통합 테스트  
│   └── unit/              # 단위 테스트
├── tests/                  # Playwright E2E 테스트
│   └── e2e/               # 모든 E2E 테스트 파일
├── test-results/           # 테스트 실행 결과
└── app/*/__tests__/        # 컴포넌트별 단위 테스트
```

### 테스트 계정
```typescript
// 기본 관리자 계정 (PRD v2.0 기준)
const TEST_ACCOUNTS = {
  admin: {
    email: 'admin@yuandi.com',
    password: 'yuandi123!',
    role: 'admin',
    permissions: ['전체 기능', '사용자 관리', '모든 주문/재고/배송 처리', '출납장부', '엑셀 다운로드']
  },
  orderManager: {
    email: 'order@yuandi.com', 
    password: 'yuandi123!',
    role: 'order_manager',
    permissions: ['주문 생성/수정', '재고 관리', '출납장부 조회']
  },
  shipManager: {
    email: 'ship@yuandi.com',
    password: 'yuandi123!', 
    role: 'ship_manager',
    permissions: ['송장 등록', '출고 처리', '출납장부 조회']
  }
};
```

#### 계정 생성 방법
```bash
# 1. Supabase Dashboard에서 auth.users에 계정 생성
# 2. user_profiles에 프로필 생성
psql $DATABASE_URL -f scripts/02.create_admin_helper.sql

# 또는 Supabase Dashboard SQL Editor에서 실행
# 파일: scripts/02.create_admin_helper.sql
```

**주의사항**: 
- `auth.users`에 계정이 먼저 생성되어야 함
- `user_profiles` 테이블의 `role` ENUM: `'admin' | 'order_manager' | 'ship_manager'`
- 스키마 초기화 후 `01.working_schema_reset.sql` 실행 필요

---

## 다국어 테스트 요구사항

### 지원 언어
- **한국어 (ko)**: `/ko` 경로
- **중국어 (zh-CN)**: `/zh-CN` 경로

### 테스트 범위
모든 시나리오는 **한국어와 중국어 버전 모두**에서 테스트되어야 합니다.

#### 테스트 체크리스트
| 기능      | 한국어 (/ko) | 중국어 (/zh-CN) | 비고                        |
| --------- | ------------ | --------------- | --------------------------- |
| 로그인    | ✅ 필수       | ✅ 필수          | 두 언어 모두 동일 계정 사용 |
| 상품 등록 | ✅ 필수       | ✅ 필수          | 다국어 입력 테스트 포함     |
| 주문 관리 | ✅ 필수       | ✅ 필수          | PCCC 코드 검증              |
| 재고 관리 | ✅ 필수       | ✅ 필수          | 숫자 표시 형식 확인         |
| 출납장부  | ✅ 필수       | ✅ 필수          | 통화 표시 확인              |
| 배송 관리 | ✅ 필수       | ✅ 필수          | 주소 형식 확인              |

### 언어별 테스트 포인트

#### 한국어 버전 (/ko)
- UI 텍스트가 모두 한국어로 표시
- 숫자 형식: `1,234,567원`
- 날짜 형식: `2025년 1월 14일`
- 에러 메시지 한국어 표시

#### 중국어 버전 (/zh-CN)
- UI 텍스트가 모두 중국어로 표시
- 숫자 형식: `¥1,234,567`
- 날짜 형식: `2025年1月14日`
- 에러 메시지 중국어 표시

### 언어 전환 테스트
1. 한국어에서 중국어로 전환 시 데이터 유지
2. 중국어에서 한국어로 전환 시 데이터 유지
3. 로그인 상태 유지
4. 입력 중인 폼 데이터 유지 확인

---

## 비즈니스 플로우 테스트 시나리오

### 📦 시나리오 1: 상품 추가 및 재고 입고

#### 테스트 목적
상품 등록부터 재고 입고, 출납장부 기록, 대시보드 반영까지의 전체 재고 관리 플로우를 검증합니다.

#### 테스트 단계

**1. 로그인 및 초기 상태 확인**
```typescript
// URL: http://localhost:8081/ko (다국어 라우팅)
await page.goto('http://localhost:8081/ko');
await page.fill('input#email, [data-testid="login-email"]', 'admin@yuandi.com');
await page.fill('input#password, [data-testid="login-password"]', 'yuandi123!');
await page.click('button[type="submit"], [data-testid="login-submit"]');
await expect(page).toHaveURL(/.*dashboard/);
```

**2. 대시보드에서 초기 재고 현황 확인**
```typescript
// 대시보드 카드에서 재고 현황 수량 기록
// ⚠️ 주의: 현재 data-testid가 없어서 텍스트 기반 셀렉터 사용
// 향후 개선: 모든 카드에 data-testid 추가 필요
const inventoryCard = page.locator('.stat-card:has-text("재고 현황"), .card:has-text("재고 현황")');
const initialStock = await inventoryCard.locator('.stat-value-large, .text-2xl, .text-xl').textContent();
console.log('초기 재고 수량:', initialStock);
```

**3. 상품 등록 (설정 → 상품관리)**
```typescript
// 설정 메뉴 이동
await page.click('text=설정, [href*="/settings"]');
await page.click('text=상품관리, [data-testid="product-management-tab"]');

// 상품 추가 버튼 클릭
await page.click('button:has-text("상품 추가"), [data-testid="product-add-button"]');

// 상품 정보 입력 (실제 소스 기반 selector 사용)
await page.selectOption('[data-testid="product-category"]', 'fashion');
await page.fill('[data-testid="product-name"]', '테스트 핸드백');
await page.fill('[data-testid="product-model"]', 'TEST-001');
await page.fill('[data-testid="product-color"]', '블랙');
await page.fill('[data-testid="product-brand"]', '테스트브랜드');
await page.fill('[data-testid="product-cost-cny"]', '100');
await page.fill('[data-testid="product-sale-price"]', '20000');
await page.fill('[data-testid="product-initial-stock"]', '10');
await page.fill('[data-testid="product-safety-stock"]', '3');

// 저장
await page.click('[data-testid="product-submit-button"]');
await expect(page.locator('[role="dialog"]')).not.toBeVisible();
```

**4. 재고 입고 처리**
```typescript
// 재고관리 메뉴 이동
await page.click('text=재고관리, [href*="/inventory"]');

// 재고 입고 버튼 클릭
await page.click('button:has-text("+ 재고 입고"), [data-testid="inbound-button"]');

// 상품 선택 및 입고 정보 입력
await page.selectOption('select[name="product_id"]', '테스트 핸드백');
await page.fill('[data-testid="stock-quantity-input"]', '5');
await page.fill('[data-testid="stock-note-textarea"]', '테스트 입고');

// 입고 처리
await page.click('[data-testid="stock-submit-button"]');
```

**5. 출납장부에서 입고 내역 확인**
```typescript
// 출납장부 메뉴 이동
await page.click('text=출납장부, [href*="/cashbook"]');

// 입고 내역 확인 (type: 'inbound', category: 'inbound')
const inboundTransaction = page.locator('tr:has-text("입고")').first();
await expect(inboundTransaction).toBeVisible();
await expect(inboundTransaction).toContainText('테스트 핸드백');
await expect(inboundTransaction).toContainText('500'); // 5개 × 100 CNY
```

**6. 대시보드에서 재고 현황 반영 확인**
```typescript
// 대시보드로 돌아가기
await page.click('text=대시보드, [href*="/dashboard"]');

// 재고 현황 증가 확인
const updatedStock = await inventoryCard.locator('.text-2xl, .text-xl').textContent();
console.log('업데이트된 재고 수량:', updatedStock);
// 초기 수량 + 입고 수량(5) = 최종 수량 검증
```

#### 예상 결과
- ✅ 상품 등록 성공 (products 테이블에 INSERT)
- ✅ 재고 입고 성공 (inventory_movements 테이블에 기록)
- ✅ 출납장부에 입고 내역 기록 (cashbook_transactions 테이블)
- ✅ 대시보드 재고 현황에 +5개 반영

---

### 📋 시나리오 2: 주문 등록

#### 테스트 목적
주문 생성부터 재고 차감, 출납장부 기록, 대시보드 반영까지의 전체 주문 처리 플로우를 검증합니다.

#### 테스트 단계

**1. 로그인 및 초기 현황 확인**
```typescript
// 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 대시보드에서 초기 현황 기록
const todayOrders = await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent();
const totalOrders = await page.locator('.card:has-text("전체 주문") .text-2xl').textContent();
const inventoryCount = await page.locator('.card:has-text("재고 현황") .text-2xl').textContent();
const revenueAmount = await page.locator('.card:has-text("매출 현황") .text-2xl').textContent();
```

**2. 주문 등록**
```typescript
// 주문 관리 메뉴 이동
await page.click('text=주문관리, [href*="/orders"]');

// 새 주문 버튼 클릭
await page.click('button:has-text("새 주문"), [data-testid="new-order-button"]');

// 고객 정보 입력 (실제 소스 기반)
await page.fill('input[name="customerName"], [data-testid="customer-name"]', '김테스트');
await page.fill('input[name="customerPhone"], [data-testid="customer-phone"]', '010-1234-5678');
await page.fill('input[name="customerEmail"], [data-testid="customer-email"]', 'test@example.com');
await page.fill('input[name="pcccCode"], [data-testid="pccc-code"]', 'P123456789012');

// 배송 정보 입력
await page.fill('input[name="shippingAddress"], [data-testid="shipping-address"]', '서울시 강남구 테헤란로 123');
await page.fill('input[name="shippingAddressDetail"], [data-testid="shipping-address-detail"]', '456호');
await page.fill('input[name="zipCode"], [data-testid="zip-code"]', '12345');

// 상품 선택 (재고 있는 상품만 표시됨)
await page.selectOption('select[name="productId"], [data-testid="product-select"]', '테스트 핸드백');
await page.fill('input[name="quantity"], [data-testid="quantity-input"]', '2');

// 메모 입력
await page.fill('textarea[name="customerMemo"], [data-testid="customer-memo"]', '테스트 주문입니다');

// 주문 등록
await page.click('button[type="submit"]:has-text("주문 등록"), [data-testid="order-submit"]');
```

**3. 출납장부에서 주문 내역 확인**
```typescript
// 출납장부 메뉴 이동
await page.click('text=출납장부, [href*="/cashbook"]');

// 주문 내역 확인 (type: 'income', category: 'sale')
const saleTransaction = page.locator('tr:has-text("판매")').first();
await expect(saleTransaction).toBeVisible();
await expect(saleTransaction).toContainText('김테스트');
await expect(saleTransaction).toContainText('40000'); // 2개 × 20000원
```

**4. 대시보드에서 변경사항 반영 확인**
```typescript
// 대시보드로 돌아가기
await page.click('text=대시보드, [href*="/dashboard"]');

// 변경사항 확인 (텍스트 기반 셀렉터 - 향후 data-testid로 개선 필요)
const updatedTodayOrders = await page.locator('.stat-card:has-text("오늘 주문") .stat-value-large').textContent();
const updatedTotalOrders = await page.locator('.stat-card:has-text("전체 주문") .stat-value-large').textContent();
const updatedInventoryCount = await page.locator('.stat-card:has-text("재고 현황") .stat-value-large').textContent();
const updatedRevenueAmount = await page.locator('.stat-card:has-text("매출 현황") .stat-value-large').textContent();

// 통화 파싱 헬퍼 함수 사용 (안정성 향상)
const parseCurrency = (text: string) => {
  if (!text) return 0;
  // 한국어: ₩1,234,567 → 1234567
  // 중국어: ¥1,234,567 → 1234567
  return parseInt(text.replace(/[^\d]/g, '')) || 0;
};

// 검증
expect(parseInt(updatedTodayOrders)).toBeGreaterThan(parseInt(todayOrders));
expect(parseInt(updatedTotalOrders)).toBeGreaterThan(parseInt(totalOrders));
expect(parseInt(updatedInventoryCount)).toBeLessThan(parseInt(inventoryCount)); // 재고 차감
expect(parseCurrency(updatedRevenueAmount)).toBeGreaterThan(parseCurrency(revenueAmount));
```

#### 예상 결과
- ✅ 주문 등록 성공 (orders 테이블에 INSERT, status: 'paid')
- ✅ 주문 아이템 생성 (order_items 테이블에 INSERT)
- ✅ 재고 자동 차감 (products.on_hand 감소)
- ✅ 출납장부에 판매 내역 기록 (cashbook_transactions, type: 'income', category: 'sale')
- ✅ 대시보드 모든 카드에 변경사항 반영

---

### 🚚 시나리오 3: 배송 정보 등록

#### 테스트 목적
주문 상태를 PAID에서 SHIPPED로 변경하고 배송 정보를 등록하는 플로우를 검증합니다.

#### 테스트 단계

**1. 로그인 및 초기 현황 확인**
```typescript
// 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 대시보드에서 모든 항목 기록
const initialStats = {
  todayOrders: await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent(),
  totalOrders: await page.locator('.card:has-text("전체 주문") .text-2xl').textContent(),
  inventoryCount: await page.locator('.card:has-text("재고 현황") .text-2xl').textContent(),
  revenueAmount: await page.locator('.card:has-text("매출 현황") .text-2xl').textContent()
};
```

**2. 배송 정보 등록**
```typescript
// 배송 관리 메뉴 이동
await page.click('text=배송관리, [href*="/shipments"]');

// 배송 대기 탭 선택
await page.click('text=배송 대기, [data-testid="pending-tab"]');

// 첫 번째 주문 행 선택 (PAID 상태)
const firstOrderRow = page.locator('tbody tr').first();
await firstOrderRow.click();

// 배송 정보 등록 버튼 클릭
await page.click('button:has-text("배송 정보 등록"), [data-testid="register-shipping-button"]');

// 배송 정보 입력 (실제 소스 기반)
await page.selectOption('select[name="courier"], [data-testid="courier-select"]', 'cj_logistics');
await page.fill('input[name="trackingNo"], [data-testid="tracking-number"]', 'CJ1234567890');
await page.fill('input[name="shippingFee"], [data-testid="shipping-fee"]', '5000');
await page.fill('input[name="actualWeight"], [data-testid="actual-weight"]', '1.5');
await page.fill('textarea[name="shipmentNote"], [data-testid="shipment-note"]', '안전하게 배송해주세요');

// 등록 버튼 클릭
await page.click('button:has-text("등록"), [data-testid="shipping-submit"]');
```

**3. 출납장부에서 배송비 내역 확인**
```typescript
// 출납장부 메뉴 이동
await page.click('text=출납장부, [href*="/cashbook"]');

// 배송비 내역 확인 (type: 'expense', category: 'shipping_fee')
const shippingTransaction = page.locator('tr:has-text("배송비")').first();
await expect(shippingTransaction).toBeVisible();
await expect(shippingTransaction).toContainText('5000');
```

**4. 대시보드에서 반영 여부 확인**
```typescript
// 대시보드로 돌아가기
await page.click('text=대시보드, [href*="/dashboard"]');

// 주문 상태 변경 확인 (PAID → SHIPPED)
// 배송비 지출로 인한 매출 현황 변화는 미미할 수 있음
const updatedStats = {
  todayOrders: await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent(),
  totalOrders: await page.locator('.card:has-text("전체 주문") .text-2xl').textContent(),
  inventoryCount: await page.locator('.card:has-text("재고 현황") .text-2xl').textContent(),
  revenueAmount: await page.locator('.card:has-text("매출 현황") .text-2xl').textContent()
};

// 주문 상태는 변경되었지만 수량은 동일해야 함
expect(updatedStats.todayOrders).toBe(initialStats.todayOrders);
expect(updatedStats.totalOrders).toBe(initialStats.totalOrders);
```

#### 예상 결과
- ✅ 주문 상태 변경 (orders.status: 'paid' → 'shipped')
- ✅ 배송 정보 등록 (shipments 테이블에 INSERT)
- ✅ 출납장부에 배송비 내역 기록 (cashbook_transactions, type: 'expense', category: 'shipping_fee')
- ✅ 대시보드 주문 수량은 동일 (상태만 변경)

---

### ✅ 시나리오 4: 배송 완료 등록

#### 테스트 목적
주문 상태를 SHIPPED에서 DONE으로 변경하여 배송 완료를 처리하는 플로우를 검증합니다.

#### 테스트 단계

**1. 로그인 및 초기 현황 확인**
```typescript
// 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 대시보드에서 모든 항목 기록
const initialStats = {
  todayOrders: await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent(),
  totalOrders: await page.locator('.card:has-text("전체 주문") .text-2xl').textContent(),
  inventoryCount: await page.locator('.card:has-text("재고 현황") .text-2xl').textContent(),
  revenueAmount: await page.locator('.card:has-text("매출 현황") .text-2xl').textContent()
};
```

**2. 배송 완료 처리**
```typescript
// 배송 관리 메뉴 이동
await page.click('text=배송관리, [href*="/shipments"]');

// 배송 중 탭 선택
await page.click('text=배송 중, [data-testid="shipping-tab"]');

// 첫 번째 주문 행 선택 (SHIPPED 상태)
const firstOrderRow = page.locator('tbody tr').first();
await firstOrderRow.click();

// 배송 정보 모달 열기
await page.click('button:has-text("배송 정보"), [data-testid="shipping-detail-button"]');

// 배송 완료 처리 (실제 DB 필드명 기반)
// orders.status: 'shipped' → 'done'
// shipments.status: 'in_transit' → 'delivered'
// shipments.actual_delivery_date: 현재 시간으로 설정
await page.click('button:has-text("배송 완료"), [data-testid="mark-delivered-button"]');

// 확인 대화상자 처리
await page.click('button:has-text("확인"), .modal button:has-text("확인")');
```

**3. 대시보드에서 반영 여부 확인**
```typescript
// 대시보드로 돌아가기
await page.click('text=대시보드, [href*="/dashboard"]');

// 변경사항 확인
const updatedStats = {
  todayOrders: await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent(),
  totalOrders: await page.locator('.card:has-text("전체 주문") .text-2xl').textContent(),
  inventoryCount: await page.locator('.card:has-text("재고 현황") .text-2xl').textContent(),
  revenueAmount: await page.locator('.card:has-text("매출 현황") .text-2xl').textContent()
};

// 주문 상태는 변경되었지만 수량은 동일해야 함
expect(updatedStats.todayOrders).toBe(initialStats.todayOrders);
expect(updatedStats.totalOrders).toBe(initialStats.totalOrders);
expect(updatedStats.inventoryCount).toBe(initialStats.inventoryCount);
```

#### 예상 결과
- ✅ 주문 상태 변경 (orders.status: 'shipped' → 'done')
- ✅ 배송 완료 처리 (shipments.status: 'in_transit' → 'delivered')
- ✅ 배송 완료 시간 기록 (shipments.actual_delivery_date: 현재 시간)
- ✅ 대시보드 주문 수량은 동일 (상태만 변경)

---

### 💸 시나리오 5: 환불 처리 등록

#### 테스트 목적
주문 상태를 DONE에서 REFUNDED로 변경하고 환불 처리를 하는 플로우를 검증합니다. (재고 복구 없음)

#### 테스트 단계

**1. 로그인 및 초기 현황 확인**
```typescript
// 로그인
await page.goto('http://localhost:8081/ko');
await page.fill('input#email', 'admin@yuandi.com');
await page.fill('input#password', 'yuandi123!');
await page.click('button[type="submit"]');

// 대시보드에서 모든 항목 기록
const initialStats = {
  todayOrders: await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent(),
  totalOrders: await page.locator('.card:has-text("전체 주문") .text-2xl').textContent(),
  inventoryCount: await page.locator('.card:has-text("재고 현황") .text-2xl').textContent(),
  revenueAmount: await page.locator('.card:has-text("매출 현황") .text-2xl').textContent()
};
```

**2. 환불 처리**
```typescript
// 배송 관리 메뉴 이동
await page.click('text=배송관리, [href*="/shipments"]');

// 배송 완료 탭 선택
await page.click('text=배송 완료, [data-testid="delivered-tab"]');

// 첫 번째 주문 행 선택 (DONE 상태)
const firstOrderRow = page.locator('tbody tr').first();
await firstOrderRow.click();

// 배송 정보 모달 열기
await page.click('button:has-text("배송 정보"), [data-testid="shipping-detail-button"]');

// 환불 처리 버튼 클릭
await page.click('button:has-text("환불 처리"), [data-testid="refund-button"]');

// 환불 사유 입력
await page.fill('textarea[name="refundReason"], [data-testid="refund-reason"]', '고객 요청으로 인한 환불');

// 환불 확인
await page.click('button:has-text("환불 확인"), [data-testid="confirm-refund"]');
```

**3. 출납장부에서 환불 내역 확인**
```typescript
// 출납장부 메뉴 이동
await page.click('text=출납장부, [href*="/cashbook"]');

// 환불 내역 확인 (type: 'expense', category: 'refund')
const refundTransaction = page.locator('tr:has-text("환불")').first();
await expect(refundTransaction).toBeVisible();
await expect(refundTransaction).toContainText('고객 요청으로 인한 환불');
// 환불 금액은 원래 주문 금액과 동일해야 함
```

**4. 대시보드에서 반영 여부 확인**
```typescript
// 대시보드로 돌아가기
await page.click('text=대시보드, [href*="/dashboard"]');

// 변경사항 확인
const updatedStats = {
  todayOrders: await page.locator('.card:has-text("오늘 주문") .text-2xl').textContent(),
  totalOrders: await page.locator('.card:has-text("전체 주문") .text-2xl').textContent(),
  inventoryCount: await page.locator('.card:has-text("재고 현황") .text-2xl').textContent(),
  revenueAmount: await page.locator('.card:has-text("매출 현황") .text-2xl').textContent()
};

// 주문 수량은 동일하지만 매출은 감소해야 함 (환불 처리)
expect(updatedStats.todayOrders).toBe(initialStats.todayOrders);
expect(updatedStats.totalOrders).toBe(initialStats.totalOrders);
expect(updatedStats.inventoryCount).toBe(initialStats.inventoryCount); // 재고 복구 없음
expect(parseCurrency(updatedStats.revenueAmount)).toBeLessThan(parseCurrency(initialStats.revenueAmount));
```

#### 예상 결과
- ✅ 주문 상태 변경 (orders.status: 'done' → 'refunded')
- ✅ 출납장부에 환불 내역 기록 (cashbook_transactions, type: 'expense', category: 'refund')
- ✅ 재고 복구 없음 (PRD v2.0 기준)
- ✅ 대시보드 매출 현황 감소 (환불 금액만큼 차감)

---

## 데이터베이스 레벨 검증 (고급)

### DB 검증을 위한 API 엔드포인트
```typescript
// 테스트에서 DB 상태를 직접 확인하는 방법
const verifyDatabaseState = async (page: Page) => {
  // 1. 재고 이동 내역 확인
  const inventoryResponse = await page.request.get('/api/inventory/movements');
  const inventoryMovements = await inventoryResponse.json();
  
  // 2. 출납장부 거래 내역 확인
  const cashbookResponse = await page.request.get('/api/cashbook/transactions');
  const cashbookTransactions = await cashbookResponse.json();
  
  // 3. 주문 상태 확인
  const ordersResponse = await page.request.get('/api/orders');
  const orders = await ordersResponse.json();
  
  return { inventoryMovements, cashbookTransactions, orders };
};
```

### 주요 테이블 검증 포인트
```sql
-- 1. 재고 이동 내역 검증
SELECT 
  product_id,
  movement_type,
  quantity,
  reference_type,
  reference_id,
  note,
  created_at
FROM inventory_movements 
WHERE created_at >= NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC;

-- 2. 출납장부 거래 내역 검증
SELECT 
  transaction_date,
  type,
  category,
  amount,
  amount_krw,
  description,
  ref_type,
  ref_id,
  created_at
FROM cashbook_transactions 
WHERE created_at >= NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC;

-- 3. 주문 상태 변경 이력 검증
SELECT 
  id,
  order_number,
  status,
  updated_at
FROM orders 
WHERE updated_at >= NOW() - INTERVAL '1 hour'
ORDER BY updated_at DESC;

-- 4. 배송 상태 변경 이력 검증
SELECT 
  id,
  order_id,
  status,
  actual_delivery_date,
  updated_at
FROM shipments 
WHERE updated_at >= NOW() - INTERVAL '1 hour'
ORDER BY updated_at DESC;
```

### 테스트에서 DB 검증 활용 예시
```typescript
// 시나리오 1: 상품 입고 후 DB 검증
test('상품 입고 후 DB 상태 확인', async ({ page }) => {
  // ... 상품 입고 테스트 실행 ...
  
  // DB 상태 검증
  const { inventoryMovements, cashbookTransactions } = await verifyDatabaseState(page);
  
  // 재고 이동 내역 확인
  const inboundMovement = inventoryMovements.find(m => m.movement_type === 'inbound');
  expect(inboundMovement).toBeTruthy();
  expect(inboundMovement.quantity).toBe(5);
  expect(inboundMovement.note).toContain('테스트 입고');
  
  // 출납장부 내역 확인
  const inboundTransaction = cashbookTransactions.find(t => t.category === 'inbound');
  expect(inboundTransaction).toBeTruthy();
  expect(inboundTransaction.type).toBe('expense');
  expect(inboundTransaction.amount).toBe(500); // 5개 × 100 CNY
});
```

---

## 폼 테스트 작성 규칙 (중요!)

### ⚠️ 필수 준수 사항
폼 테스트를 작성할 때 반드시 다음 순서를 따라야 합니다:

1. **실제 소스 파일 확인**
   - 먼저 소스 파일에서 실제 input name, id, data-testid 속성을 확인
   - 추측하지 말고 실제 코드에 있는 selector만 사용

2. **스키마 검증 규칙 파악**
   - `/scripts/01.working_schema_reset.sql` 에서 validation 규칙 확인
   - 필수 필드, 데이터 타입, 제약 조건 파악

3. **테스트 코드 작성**
   - 확인된 selector와 validation 규칙 기반으로 작성
   - 추측이나 가정 없이 실제 구현된 내용만 테스트

### 주요 폼 Selector 참조 (실제 소스 기반)

#### 로그인 폼
```typescript
// 실제 소스: app/login/page.tsx, app/[locale]/auth/signin/page.tsx
const LOGIN_SELECTORS = {
  email: 'input#email, [data-testid="login-email"]',
  password: 'input#password, [data-testid="login-password"]', 
  submit: 'button[type="submit"], [data-testid="login-submit"]',
  // 다국어 라우팅: /ko, /zh-CN
  url: 'http://localhost:8081/ko' // 또는 /zh-CN
};
```

#### 상품 등록 폼
```typescript
// 실제 소스: app/components/inventory/product-add-modal.tsx
const PRODUCT_FORM_SELECTORS = {
  category: '[data-testid="product-category"]',
  name: '[data-testid="product-name"]',
  model: '[data-testid="product-model"]',
  color: '[data-testid="product-color"]',
  brand: '[data-testid="product-brand"]',
  costCny: '[data-testid="product-cost-cny"]',
  salePriceKrw: '[data-testid="product-sale-price"]',
  initialStock: '[data-testid="product-initial-stock"]',
  safetyStock: '[data-testid="product-safety-stock"]',
  submitButton: '[data-testid="product-submit-button"]',
  cancelButton: '[data-testid="product-cancel-button"]'
};
```

#### 주문 등록 폼
```typescript
// 실제 소스: app/components/orders/order-add-modal.tsx
const ORDER_FORM_SELECTORS = {
  customerName: 'input[name="customerName"], [data-testid="customer-name"]',
  customerPhone: 'input[name="customerPhone"], [data-testid="customer-phone"]',
  customerEmail: 'input[name="customerEmail"], [data-testid="customer-email"]',
  pcccCode: 'input[name="pcccCode"], [data-testid="pccc-code"]',
  shippingAddress: 'input[name="shippingAddress"], [data-testid="shipping-address"]',
  shippingAddressDetail: 'input[name="shippingAddressDetail"], [data-testid="shipping-address-detail"]',
  zipCode: 'input[name="zipCode"], [data-testid="zip-code"]',
  productSelect: 'select[name="productId"], [data-testid="product-select"]',
  quantity: 'input[name="quantity"], [data-testid="quantity-input"]',
  customerMemo: 'textarea[name="customerMemo"], [data-testid="customer-memo"]',
  submitButton: 'button[type="submit"]:has-text("주문 등록"), [data-testid="order-submit"]'
};
```

#### 배송 정보 폼
```typescript
// 실제 소스: app/components/shipping/shipping-modal.tsx
const SHIPPING_FORM_SELECTORS = {
  courier: 'select[name="courier"], [data-testid="courier-select"]',
  trackingNumber: 'input[name="trackingNo"], [data-testid="tracking-number"]',
  shippingFee: 'input[name="shippingFee"], [data-testid="shipping-fee"]',
  actualWeight: 'input[name="actualWeight"], [data-testid="actual-weight"]',
  shipmentNote: 'textarea[name="shipmentNote"], [data-testid="shipment-note"]',
  submitButton: 'button:has-text("등록"), [data-testid="shipping-submit"]'
};
```

#### 재고 조정 폼
```typescript
// 실제 소스: app/components/inventory/stock-modal.tsx
const STOCK_FORM_SELECTORS = {
  quantity: '[data-testid="stock-quantity-input"]',
  note: '[data-testid="stock-note-textarea"]',
  submitButton: '[data-testid="stock-submit-button"]',
  cancelButton: '[data-testid="stock-cancel-button"]'
};
```

### SQL 스키마 기반 Validation 규칙

#### 상품 테이블 (products)
```sql
-- 필수 필드
name_ko TEXT NOT NULL,
name_zh TEXT NOT NULL,
price_krw NUMERIC(10,2) NOT NULL DEFAULT 0,
cost_cny NUMERIC(10,2) NOT NULL DEFAULT 0,
on_hand INTEGER NOT NULL DEFAULT 0,

-- 제약 조건
CHECK (price_krw >= 0),
CHECK (cost_cny >= 0),
CHECK (on_hand >= 0)
```

#### 주문 테이블 (orders)
```sql
-- 필수 필드
customer_name TEXT NOT NULL,
customer_phone TEXT NOT NULL,
pccc TEXT,
shipping_address_line1 TEXT,
shipping_postal_code TEXT,
status order_status NOT NULL DEFAULT 'paid',
total_krw NUMERIC(12,2) NOT NULL DEFAULT 0
```

#### 출납장부 테이블 (cashbook_transactions)
```sql
-- 필수 필드
transaction_date DATE NOT NULL DEFAULT CURRENT_DATE,
type VARCHAR(20) NOT NULL CHECK (type IN ('income', 'expense', 'adjustment')),
category VARCHAR(50) NOT NULL,
amount NUMERIC(15,2) NOT NULL,
amount_krw NUMERIC(15,2) NOT NULL,
description TEXT NOT NULL
```

---

## 테스트 실행 방법

### 로컬 서버 설정 (중요!)
```bash
# ⚠️ 테스트 전 서버 구동 확인 필수
# 포트 8081 사용 (WSL 환경에서 3000 포트 충돌 방지)
PORT=8081 pnpm dev

# Windows 브라우저에서 접속
# http://localhost:8081
```

### Playwright E2E 테스트
```bash
# 테스트 환경 설정
npm install -D @playwright/test

# 브라우저 설치
npx playwright install

# 테스트 실행 (로컬)
BASE_URL=http://localhost:8081 npx playwright test

# 테스트 실행 (배포 환경)
BASE_URL=https://00-yuandi-erp.vercel.app npx playwright test

# UI 모드로 실행 (디버깅용)
npx playwright test --ui

# 특정 테스트만 실행
npx playwright test tests/e2e/business-flow.spec.ts
```

### 다국어 테스트 실행
```bash
# 한국어 버전 테스트
npx playwright test tests/e2e/scenario-1-korean.spec.ts

# 중국어 버전 테스트
npx playwright test tests/e2e/scenario-1-chinese.spec.ts

# 다국어 통합 테스트 (한국어 + 중국어)
npx playwright test tests/e2e/scenario-1-korean.spec.ts tests/e2e/scenario-1-chinese.spec.ts

# 병렬 실행으로 빠르게 테스트
npx playwright test tests/e2e/scenario-1-*.spec.ts --workers=2

# 특정 언어만 테스트 (grep 사용)
npx playwright test --grep "한국어"
npx playwright test --grep "中文"
```

### 간단한 테스트 스크립트
```bash
# 비즈니스 플로우 테스트 실행
node test-business-flow.js

# 특정 시나리오만 실행
npx playwright test tests/e2e/scenario-1-product-inventory.spec.ts
npx playwright test tests/e2e/scenario-2-order-registration.spec.ts
npx playwright test tests/e2e/scenario-3-shipping-registration.spec.ts
npx playwright test tests/e2e/scenario-4-delivery-completion.spec.ts
npx playwright test tests/e2e/scenario-5-refund-processing.spec.ts
```

### 테스트 데이터 준비
```bash
# 테스트 데이터 초기화 (필요시)
psql -h your-supabase-host -U postgres -d postgres -f scripts/01.working_schema_reset.sql
psql -h your-supabase-host -U postgres -d postgres -f scripts/03.test_data.sql

# 또는 Supabase Dashboard에서 직접 실행
```

---

## 실제 테스트 실행 결과 및 이슈

### 테스트 환경
- **로컬 서버**: http://localhost:8081
- **배포 서버**: https://00-yuandi-erp.vercel.app/
- **테스트 일자**: 2025-01-14

### 확인된 이슈 및 해결 방법

#### 1. 다국어 라우팅 문제
- **문제**: `/login` 직접 접근 시 다국어 라우팅으로 인한 404 에러
- **원인**: Next.js i18n 미들웨어가 `/login`을 `/[locale]/login`으로 변환하나 해당 페이지 없음
- **해결**: 다국어 경로로 직접 접근
```typescript
// ❌ 잘못된 방법
await page.goto('http://localhost:8081/login'); // 404 에러

// ✅ 올바른 방법
await page.goto('http://localhost:8081/ko'); // 한국어
await page.goto('http://localhost:8081/zh-CN'); // 중국어
```

#### 2. 재고 관리 페이지 UI 구조 (실제 소스 분석)
**버튼 및 기능**:
- 재고 입고: `"+ 재고 입고"` (inventory/page.tsx)
- 재고 수정: `"+ 재고 수정"` (inventory/page.tsx)
- 상품 추가: 설정 → 상품관리에서 별도 처리

**테이블 컬럼 구조**:
```
0: 상품명 (name_ko/name_zh)
1: 모델 (model)
2: 브랜드 (brand_ko/brand_zh)
3: 색상 (color_ko/color_zh)
4: 카테고리 (category)
5: 재고 수량 (on_hand)
6: 원가(CNY) (cost_cny)
7: 판매가(KRW) (price_krw)
8: 상태 (재고 부족 여부)
9: 액션 (입고/수정 버튼)
```

#### 3. 모달 간섭 문제
- **문제**: 상품 상세 모달이 자동으로 열려 버튼 클릭 방해
- **증상**: "intercepts pointer events" 에러
- **해결**: 모달 감지 및 닫기 처리
```typescript
// 모달이 열려있으면 닫기
const modal = page.locator('[role="dialog"]');
if (await modal.isVisible()) {
  await modal.locator('button:has-text("×"), button:has-text("닫기")').click();
  await page.waitForSelector('[role="dialog"]', { state: 'hidden' });
}
```

#### 4. data-testid 속성 활용 (실제 소스 기반)
**상품 관리**:
```typescript
// app/components/inventory/product-add-modal.tsx
'[data-testid="product-category"]'
'[data-testid="product-name"]'
'[data-testid="product-model"]'
'[data-testid="product-color"]'
'[data-testid="product-brand"]'
'[data-testid="product-cost-cny"]'
'[data-testid="product-sale-price"]'
'[data-testid="product-initial-stock"]'
'[data-testid="product-safety-stock"]'
'[data-testid="product-submit-button"]'
```

**재고 관리**:
```typescript
// app/components/inventory/stock-modal.tsx
'[data-testid="stock-quantity-input"]'
'[data-testid="stock-note-textarea"]'
'[data-testid="stock-submit-button"]'
```

**주문 관리**:
```typescript
// app/components/orders/order-add-modal.tsx
'[data-testid="customer-name"]'
'[data-testid="customer-phone"]'
'[data-testid="customer-email"]'
'[data-testid="pccc-code"]'
'[data-testid="shipping-address"]'
'[data-testid="product-select"]'
'[data-testid="quantity-input"]'
```

#### 5. 대시보드 카드 구조 (실제 소스 분석)
**카드 구성** (app/[locale]/dashboard/page.tsx):
```typescript
// 대시보드 카드들
const DASHBOARD_CARDS = {
  todayOrders: '.card:has-text("오늘 주문") .text-2xl',
  totalOrders: '.card:has-text("전체 주문") .text-2xl', 
  inventoryCount: '.card:has-text("재고 현황") .text-2xl',
  revenueAmount: '.card:has-text("매출 현황") .text-2xl',
  shippingReady: '.card:has-text("배송 대기") .text-2xl',
  shippingInProgress: '.card:has-text("배송 중") .text-2xl',
  shippingCompleted: '.card:has-text("배송 완료") .text-2xl',
  refunded: '.card:has-text("환불") .text-2xl'
};
```

### 테스트 실행 결과 요약
| 테스트 항목     | 상태   | 비고                           |
| --------------- | ------ | ------------------------------ |
| 로그인 (한국어) | ✅ 성공 | /ko 경로 사용                  |
| 로그인 (중국어) | ✅ 성공 | /zh-CN 경로 사용               |
| 상품 등록       | ✅ 성공 | data-testid 기반 selector 사용 |
| 재고 입고       | ✅ 성공 | 모달 간섭 문제 해결            |
| 주문 등록       | ✅ 성공 | PCCC 코드 검증 포함            |
| 배송 정보 등록  | ✅ 성공 | 이중 배송 시스템 지원          |
| 배송 완료 처리  | ✅ 성공 | 상태 변경 확인                 |
| 환불 처리       | ✅ 성공 | 재고 복구 없음 확인            |
| 출납장부 연동   | ✅ 성공 | 모든 거래 내역 기록            |
| 대시보드 반영   | ✅ 성공 | 실시간 통계 업데이트           |
| 다국어 UI       | ✅ 성공 | 한국어/중국어 정상 표시        |

### 개선 권장사항

#### 🔥 긴급 개선사항
1. **data-testid 전면 적용**: 모든 핵심 UI 요소에 data-testid 추가
   - 대시보드 카드: `[data-testid="today-orders-card"]`, `[data-testid="inventory-card"]` 등
   - 네비게이션 메뉴: `[data-testid="nav-orders"]`, `[data-testid="nav-inventory"]` 등
   - 탭/버튼: `[data-testid="pending-tab"]`, `[data-testid="shipping-tab"]` 등

2. **통화 파싱 안정성**: `parseCurrency()` 헬퍼 함수 표준화
   ```typescript
   // 공통 유틸리티로 분리
   export const parseCurrency = (text: string): number => {
     if (!text) return 0;
     return parseInt(text.replace(/[^\d]/g, '')) || 0;
   };
   ```

3. **DB 검증 강화**: API 엔드포인트를 통한 백엔드 상태 확인
   - `/api/inventory/movements` - 재고 이동 내역
   - `/api/cashbook/transactions` - 출납장부 거래
   - `/api/orders` - 주문 상태

#### 📋 일반 개선사항
4. **다국어 라우팅**: `/login` 직접 접근 시 적절한 리다이렉트 처리
5. **모달 관리**: 테스트 모드에서 자동 모달 비활성화 옵션
6. **타임아웃**: 네트워크 지연 고려한 충분한 대기 시간 설정
7. **에러 핸들링**: 테스트 실패 시 더 명확한 에러 메시지 제공
8. **테스트 데이터**: 각 시나리오별 독립적인 테스트 데이터 세트 제공
9. **계정 생성 자동화**: 테스트 실행 시 자동으로 테스트 계정 생성

---

---

## 📚 참조 문서

### 주요 문서
- **[PRD v2.0](./PRD.md)**: 제품 요구사항 명세서
- **[Database Schema v1.1](./DATABASE_ERD.md)**: 데이터베이스 스키마
- **[Setup Guide](./SETUP_GUIDE.md)**: 초기 환경 구축 가이드
- **[Deployment Guide](./DEPLOYMENT_GUIDE.md)**: 배포 프로세스 가이드

### 소스 코드 참조
- **로그인**: `app/login/page.tsx`, `app/[locale]/auth/signin/page.tsx`
- **상품 관리**: `app/components/inventory/product-add-modal.tsx`
- **재고 관리**: `app/[locale]/inventory/page.tsx`
- **주문 관리**: `app/components/orders/order-add-modal.tsx`
- **배송 관리**: `app/components/shipping/shipping-modal.tsx`
- **출납장부**: `app/[locale]/cashbook/page.tsx`
- **대시보드**: `app/[locale]/dashboard/page.tsx`

### SQL 스키마 참조
- **스키마 초기화**: `scripts/01.working_schema_reset.sql`
- **테스트 데이터**: `scripts/03.test_data.sql`
- **관리자 계정**: `scripts/02.create_admin_helper.sql`

---

**문서 관리**
- **작성일**: 2025-01-13
- **최종 수정**: 2025-01-14
- **버전**: v1.2
- **다음 검토**: 2025-01-21
- **담당자**: YUANDI 개발팀
- **검증 상태**: 소스 코드, PRD, SQL 스키마 기반 검증 완료
- **개선사항**: 로케일 의존성, DB 검증, 통화 파싱 안정성 개선